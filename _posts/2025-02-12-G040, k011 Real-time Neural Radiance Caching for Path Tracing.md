---
layout: mypost
title: G040, k011 Real-time Neural Radiance Caching for Path Tracing
categories: [Neural Radiance Caching]
---

# 链接



# 文章难点解析

这篇论文是关于实时路径追踪渲染中的神经辐射缓存（Neural Radiance Caching, NRC）技术的研究。

## 论文的核心内容

这篇论文介绍了一种名为“实时神经辐射缓存”的技术，用于提高路径追踪渲染的效率。路径追踪是一种基于物理的渲染方法，能够生成高质量的图像，但通常计算成本很高，难以实时渲染。神经辐射缓存通过使用神经网络来近似场景中的辐射场（即光线在场景中的传播和散射情况），从而减少计算量，实现实时渲染。

## 关键点解读

### 问题背景

路径追踪渲染虽然效果好，但计算复杂度高，尤其是对于高阶间接照明（即多次反射的光线）。

传统的辐射缓存方法（如辐射度缓存、辐射度探针等）虽然可以加速渲染，但存在一些问题，比如需要预计算、对场景的动态变化适应性差、需要复杂的插值和更新策略等。

### 神经辐射缓存的核心思想

使用神经网络来近似辐射场，而不是传统的缓存方法。神经网络能够自动学习场景中的光照模式，从而减少手动干预和复杂的启发式规则。

神经网络在渲染过程中实时训练（在线学习），以适应动态场景的变化，如灯光、几何形状、材质的变化等。

### 技术细节

在线训练：神经网络通过自我训练（self-training）的方式进行更新。它利用自身在路径后续顶点的预测结果作为训练目标，从而以较少的计算成本实现多跳照明的模拟。

路径终止策略：通过一种基于路径扩散面积的启发式方法来决定何时终止路径并查询神经缓存，从而减少计算量。

输入编码：为了提高神经网络的准确性，输入数据不仅包括空间方向坐标，还包括表面法线、粗糙度、漫反射和镜面反射等参数。这些参数通过特定的编码方式（如频率编码和一滴编码）被转换为更高维度的特征，以便神经网络更好地学习。

全融合神经网络：为了充分利用现代GPU的计算能力，作者设计了一种全融合的神经网络架构，将整个网络作为一个单独的GPU内核实现，最大限度地减少了对慢速全局内存的访问，提高了渲染效率。

### 实验结果

在多个具有挑战性的场景中，神经辐射缓存技术显著降低了噪声，同时保持了较高的帧率（实时性能）。例如，在“Zero Day”场景中，使用神经辐射缓存后，帧率从71fps提升到126fps，同时图像质量也得到了显著提升。

与传统的动态漫反射全局光照（DDGI）技术相比，神经辐射缓存虽然在性能上略逊一筹，但在减少偏差（即更接近真实光照效果）方面表现更好，并且能够更好地处理非朗伯材质（如高光、镜面反射等）。

### 讨论与未来工作

作者指出，尽管神经辐射缓存能够很好地处理动态场景，但在某些情况下（如复杂的镜面反射路径）仍存在局限性。

未来的工作方向包括探索预计算与在线学习的结合、改进路径终止策略、研究新的网络输入特征以更好地处理阴影和焦散等复杂光照现象，以及将该技术应用于离线渲染和体积渲染等领域。

### 总结

这篇论文提出了一种创新的实时路径追踪渲染技术，通过神经网络来近似场景中的辐射场，从而在保持高质量渲染效果的同时，显著提高了渲染效率。这种方法特别适合于动态场景的实时渲染，为实时图形学领域提供了一种新的解决方案。

# 详细介绍

这篇论文《Real-time Neural Radiance Caching for Path Tracing》由 NVIDIA 的 Thomas Müller 等人撰写，发表于 2021 年。论文提出了一种实时神经辐射缓存（Neural Radiance Caching, NRC）技术，用于加速路径追踪渲染中的全局光照计算。以下是对论文的详细介绍：

## 研究背景

路径追踪是一种基于物理的渲染方法，能够生成高质量的图像，但计算成本很高，尤其是对于高阶间接照明（多次反射的光线）。传统的辐射缓存方法（如辐射度缓存、辐射度探针等）虽然可以加速渲染，但存在一些问题：

预计算：需要预先计算缓存点，难以适应动态场景。

复杂性：依赖于复杂的插值和更新策略，容易引入渲染伪影。

性能不稳定：计算量和内存占用会随着场景复杂度变化，难以保证稳定的帧率。

## 研究目标

论文的目标是开发一种能够处理完全动态场景的实时全局光照技术，同时满足以下设计原则：

动态内容：支持任意动态的相机、灯光、几何形状和材质，无需预计算。

鲁棒性：对材质和场景几何形状不敏感，能够适应用户生成的内容。

可预测的性能和资源消耗：计算量和内存占用稳定，与场景复杂度无关，渲染成本最多与像素数量呈线性关系。

## 神经辐射缓存（NRC）技术

### 核心思想

神经辐射缓存通过神经网络来近似场景中的辐射场（即光线在场景中的传播和散射情况），从而减少计算量，实现实时渲染。该技术的核心在于：

在线训练：神经网络在渲染过程中实时训练，以适应动态场景的变化。

自我训练（Self-training）：利用神经网络自身的预测结果作为训练目标，从而以较少的计算成本实现多跳照明的模拟。

路径终止策略：通过一种基于路径扩散面积的启发式方法来决定何时终止路径并查询神经缓存，从而减少计算量。

### 算法概述

渲染每一帧的过程包括：

路径追踪与缓存查询：对于每个像素，追踪一条短路径，并在路径的终端查询神经辐射缓存。

自我训练：选择一小部分路径（约 3%）进行扩展，形成“训练路径”，并在这些路径的终端收集辐射估计值，用于训练神经网络。

路径终止：根据路径的扩散面积决定何时终止路径，以减少计算量并避免缓存的不准确。

### 输入编码

为了提高神经网络的准确性，输入数据不仅包括空间方向坐标，还包括表面法线、粗糙度、漫反射和镜面反射等参数。这些参数通过特定的编码方式（如频率编码和一滴编码）被转换为更高维度的特征，以便神经网络更好地学习。

### 全融合神经网络

为了充分利用现代 GPU 的计算能力，作者设计了一种全融合的神经网络架构，将整个网络作为一个单独的 GPU 内核实现，最大限度地减少了对慢速全局内存的访问，提高了渲染效率。

## 实验结果

论文通过多个具有挑战性的场景展示了神经辐射缓存技术的效果：

噪声减少：显著降低了间接照明的噪声，同时引入的偏差很小。

实时性能：在 1920×1080 分辨率下，所有测试场景的帧率均超过 60fps。

与 ReSTIR 结合：与 ReSTIR（一种直接照明降噪技术）结合使用时，效果更佳，能够同时减少直接和间接照明的噪声。

与 DDGI 对比：与动态漫反射全局光照（DDGI）相比，神经辐射缓存虽然在性能上略逊一筹，但在减少偏差（即更接近真实光照效果）方面表现更好，并且能够更好地处理非朗伯材质（如高光、镜面反射等）。

## 讨论与未来工作

尽管神经辐射缓存能够很好地处理动态场景，但在某些情况下（如复杂的镜面反射路径）仍存在局限性。未来的工作方向包括：

预计算与在线学习的结合：探索预计算与在线学习的结合，以进一步提高性能。

改进路径终止策略：研究更准确的路径终止策略，以更好地处理镜面反射路径。

新的网络输入特征：探索新的网络输入特征，以更好地处理阴影和焦散等复杂光照现象。

离线渲染应用：将该技术应用于离线渲染，以提高高阶间接照明的计算效率。

体积渲染：探索该技术在体积渲染中的应用。

## 总结

论文提出了一种创新的实时路径追踪渲染技术，通过神经网络来近似场景中的辐射场，从而在保持高质量渲染效果的同时，显著提高了渲染效率。这种方法特别适合于动态场景的实时渲染，为实时图形学领域提供了一种新的解决方案。尽管存在一些局限性，但其在实时渲染中的表现已经非常出色，未来还有很大的改进空间。

# 原文翻译

## 3 神经辐射缓存

我们的目标是使用单一神经网络对辐射度进行缓存，该网络将空间方向坐标映射到辐射度值，并且在实时环境中进行训练，以支持动态场景。我们选择近似散射辐射度，因为它是渲染方程 [Kajiya 1986] 中计算成本最高的部分。散射辐射度 $L_s(x, \omega)$ 定义为：

$$
L_s(x, \omega) := \int_{S^2} f_s(x, \omega, \omega_i) L_i(x, \omega_i) | \cos \theta_i | \, d\omega_i \quad (1)
$$

它表示从点 $x$ 沿方向 $\omega$ 离开的辐射能量，这些能量在 $x$ 点处发生散射。对于给定的入射方向 $\omega_i$，被积函数是双向散射分布函数（BSDF） $f_s(x, \omega, \omega_i)$、入射辐射度 $L_i(x, \omega_i)$ 以及缩放项 $| \cos \theta_i |$ 的乘积，其中 $\theta_i$ 是 $\omega_i$ 与 $x$ 点处表面法线之间的夹角。我们的神经网络通过缓存的辐射度 $L_{bs}$ 来近似 $L_s$。

在本节中，我们将讨论构建神经辐射缓存的关键算法选择，这些选择对于满足第1节中概述的设计原则至关重要。实时性能通过优化的全融合网络实现，相关内容将在第4节中讨论。

### 3.1 算法概述

渲染单帧图像包括计算像素颜色以及更新神经辐射缓存；请参见图2的示意图。首先，我们为每个像素追踪短的渲染路径，并在辐射缓存提供的近似值被认为足够准确时终止这些路径。我们使用由Bekaert等人 [2003] 提出的启发式方法（最初是在光子密度估计的背景下开发的），仅在路径的扩散足够大以模糊缓存的小误差时才查询缓存（更多细节见第3.4节）。在每个中间顶点处，我们使用下一次事件估计来对光源进行光的积分。为此，我们在主顶点处使用屏幕空间ReSTIR [Bitterli等人 2020]，在后续顶点处结合双向散射分布函数（BSDF）通过多重要性采样 [Veach和Guibas 1995] 使用LightBVH [Moreau等人 2019]。在终端顶点 $x_k$ 处截断路径后，我们评估神经辐射缓存以近似 $L_s(x_k, \omega_k)$。

其次，为了训练辐射缓存，我们通过添加几个顶点（训练后缀）来延长部分短渲染路径（通常少于3%）。与之前类似，我们在训练后缀的面积扩散足够大时终止这些较长的训练路径；为此，我们将查询顶点 $x_k$ 视为主顶点（见图5）。在大多数情况下，后缀由一个顶点组成。沿着较长训练路径的所有顶点收集的辐射估计值被用作训练辐射缓存的参考值。

### 讨论

将路径终止到辐射缓存中可以节省计算，并且重要的是，它用一个聚合了空间和时间上附近位置样本的近似值替换了单样本估计。因此，方差得以降低。然而，缓存是否适用于实时应用，仍然取决于我们更新和查询缓存的效率和速度。

**图 5.** 一旦我们的短渲染路径的散射交互足够模糊信号，我们就会将这些路径终止到神经辐射缓存中。为此，我们将路径的足迹面积 $a(x_1x_2)$ 与图像平面上直接可见的表面面积 $a_0$ 进行比较。较长的训练路径通过将相同的启发式方法应用于后缀的顶点来终止，即我们比较 $a(x_2x_3x_4)$ 与 $a_0$。

### 3.2 通过自训练快速适应缓存

在任何数据驱动的方法中，近似的质量取决于网络训练所依据的目标值 $L_s$ 的准确性。实时渲染动态场景的独特挑战要求我们根据变化的辐射场持续调整神经辐射缓存，例如由于移动的光源或几何形状的变化。这意味着我们既没有奢侈地预先计算精确的目标值 $L_s$，也不能容忍会减缓收敛的噪声估计。

我们没有通过蒙特卡洛路径追踪 [Müller et al. 2019; Müller et al. 2020] 来估计目标值，而是利用神经辐射缓存本身，在较长训练路径的终端顶点处对其进行评估。收集到的辐射度被传输到前面的顶点，在每个顶点处生成一个用于训练神经网络的目标值。使用自身的值更新神经辐射缓存类似于 Q 学习的概念 [Dahm and Keller 2018; Keller and Dahm 2019]。

自训练方法与完全路径追踪估计相比有两个明显的优势：它在估计 $L_s$ 时将大部分不期望的噪声交换为（潜在的）偏差。它还允许在训练过程被迭代的情况下捕获全局光照：一个训练路径所学到的辐射度会在下一次迭代中通过多个其他训练路径被传输。因此，每次迭代都会增加模拟的光反弹次数。这让人想起渐进式辐射度算法 [Martin and Einarsson 2010]，它们通过迭代单次反弹的辐射传输来模拟多次反弹的漫反射传输。

然而，自训练神经辐射缓存也有两个缺点：首先，训练路径的最后一个顶点可能到达辐射缓存尚未训练的场景位置，这可能会导致更大的近似误差。第二个缺点是，迭代优化可能只模拟了多反弹光照的一部分，而不是所有光传输。具体来说，只有可以通过训练路径到达的发射器的传输才会被进一步反弹，而且只有当后续帧中训练路径的尾部落在当前优化点附近时（即图2中的 $y_4$ 需要靠近 $y_2$ 或 $y_3$），才会如此。

这两个缺点几乎可以免费缓解，方法是使一小部分训练路径真正无偏见，从而注入正确的源值以供自训练机制传播。我们使用 $u = 1/16$，即每16个训练后缀中，只有一个是通过俄罗斯轮盘赌来终止的。

### 3.3 时间稳定的缓存查询

在渲染动态内容时，例如改变相机位置或动画几何形状，神经辐射缓存需要持续适应，这迫使我们在通过梯度下降优化网络时使用较高的学习率。此外，我们还在每帧中执行多次（在我们的情况下是4次）梯度下降步骤，这进一步加快了适应速度。

然而，这种激进的优化计划的一个副作用是时间上的伪影，例如闪烁和跨渲染帧的振荡——即使场景和相机是静态的，也会出现这种情况，因为估计的辐射目标存在噪声。

因此，我们提出通过平均优化产生的网络权重来抑制这种振荡。具体来说，我们计算由第 $t$ 次梯度下降步骤产生的网络权重 $W_t$ 的**指数移动平均值（EMA）**，从而创建了一组用于渲染时评估缓存的第二组权重 $W'_t$。指数移动平均值的计算公式为：

$$
W'_t := ((1 - \alpha) / \eta_t) \cdot W_t + \alpha \cdot \eta_{t-1} \cdot W'_{t-1}, \quad \text{其中} \quad \eta_t := 1 - \alpha^t \quad (2)
$$

其中，$\eta_t$ 修正了小 $t$ 时平均值的偏差，$\alpha \in [0, 1]$ 控制指数平均的强度。我们使用 $\alpha = 0.99$，以在快速适应和权重 $W'_t$ 的时间稳定性之间取得良好的平衡；我们在图3中展示了时间稳定性。请注意，平均过程不会反馈到训练循环中；$W'_t$ 依赖于 $W_t$，但反之则不然。然而，最近的研究表明，经过EMA滤波的权重 $W'_t$ 可能比优化器产生的任何原始权重 $W_t$ 更接近最优值 [Izmailov et al. 2018]。

事实上，图4显示了从头开始训练的辐射缓存的演变过程，其既渐进又迅速。在路径末端使用缓存而不是直接可视化它，可以过滤其近似误差，仅需8帧（约70毫秒）即可达到令人满意的质量；更多关于动画内容的结果，请参见补充视频。

### 3.4 路径终止

所有路径都根据基于路径顶点面积扩散的简单启发式方法终止，如图5中的圆锥所示；我们将相机顶点索引为 $x_0$，主顶点索引为 $x_1$。一旦扩散变得足够大以模糊缓存的小尺度误差（参见图12），我们就终止路径。根据 Bekaert 等人 [2003] 的方法，沿子路径 $x_1 \cdots x_n$ 的面积扩散可以通过以下公式近似计算：

$$
a(x_1 \cdots x_n) = \left( \sum_{i=2}^{n} \sqrt{ \frac{\|x_{i-1} - x_i\|^2}{p(\omega_i | x_{i-1}, \omega) | \cos \theta_i |} } \right)^2, \quad (3)
$$

其中 $p$ 是 BSDF 采样概率密度函数，$\theta_i$ 是 $\omega_i$ 与 $x_i$ 处表面法线之间的夹角。

为了终止路径，我们将子路径扩散 $a(x_1 \cdots x_n)$ 与从相机视角看到的主顶点的扩散进行比较，这可以近似为：

$$
a_0 := \frac{\|x_0 - x_1\|^2}{4\pi \cos \theta_1}, \quad (4)
$$

即，如果 $a(x_1 \cdots x_n) > c \cdot a_0$，我们将终止路径，其中 $c$ 是一个超参数，用于在方差（较长路径）与偏差和速度（较短路径）之间进行权衡。我们发现 $c = 0.01$ 可以产生令人满意的结果。

最后，如果路径被选择为训练路径，则启发式方法将再次使用，这次是当 $a(x_n \cdots x_m) > c \cdot a_0$ 时终止训练后缀。图5中展示了训练路径的启发式方法，其中路径的短渲染部分在顶点 $n = 2$ 处结束，训练后缀在 $n = 4$ 处结束。

### 3.5 实时路径追踪中的摊销计算

我们的目标是实时应用，设定了16.6毫秒的渲染预算，以实现每秒60帧的帧率。这个预算包括路径追踪、在每个顶点处的着色，以及查询和更新缓存。实际上，这留给处理缓存开销的时间只有几毫秒。

我们不仅通过第4节中描述的全融合网络来解决这个问题，还在路径追踪器的集成中进行了优化。我们通过将视口分块来交错短渲染路径和长训练路径。使用一个随机偏移量，我们将每个块中的一条路径提升为长训练路径（见图5），从而在屏幕空间中形成一个均匀稀疏的训练路径集合。仅仅通过延长渲染路径来获得训练路径的方法大大减少了开销，因为计算在两者之间是共享的。这与基于探测体积的缓存技术形成对比，后者使用一组单独的光线来更新缓存，这些光线并不直接贡献于图像本身。

一旦追踪完成，我们通过从每条短渲染路径的终端顶点反向传播缓存的辐射度来重建图像。对于训练路径，我们跟踪两个值：上述的渲染辐射度和训练辐射度。对于训练路径上的每个顶点，我们将训练辐射度（连同顶点信息）存储在一个数组中；它将被用作优化缓存的目标值。

我们使用线性同余生成器将所有训练记录打乱，并将它们分配到 $s$ 个训练批次中，每个批次包含 $l$ 条训练记录。打乱操作确保训练批次与图像区域不相关。每个训练批次用于执行缓存的一个优化步骤。为了确保工作负载的稳定性，我们使用自适应分块机制来匹配目标训练预算；在实践中，我们选择 $s = 4$ 个训练批次，每个批次包含 $l = 16384$ 条记录，总共每帧有 65536 条训练记录。我们根据图像重建过程中生成的训练记录数量动态调整每帧的分块大小。与其他缓存技术类似，训练成本与图像分辨率解耦，因为我们使用了有限数量的训练记录。最后，我们观察到训练我们的神经辐射缓存相当于对空间和时间上附近位置的许多样本进行回归，即一种路径空间去噪的形式。因此，通过用缓存近似值替换单样本辐射度估计，方差显著降低。

### 3.6 输入编码

Ren 等人 [2013] 指出，仅使用散射辐射度的空间方向坐标 $(x, \omega)$ 作为神经网络的输入，无法使其很好地表示辐射度。因此，输入被增加了与散射辐射度相关的其他参数：表面法线 $n$、表面粗糙度 $r$、漫反射率 $\alpha$ 和镜面反射率 $\beta$。能够利用这些相关性，神经近似变得更加准确。

当这些相关性是（近乎）线性时，网络更容易识别它们。对于漫反射率和镜面反射率，它们已经是线性的，因此我们直接将它们输入到网络中。然而，$x$、$\omega$、$n$ 和 $r$ 与散射辐射度之间的关系高度非线性。对于这些量，选择一个合适的编码到更高维度空间可以使关系更加线性，从而提高神经近似的准确性[^3^]。

额外的维度并非没有代价，因为它们会增加所需的内存流量以及神经网络第一层的成本。因此，我们的目标是在利用线性化优势的同时，尽可能少地增加额外维度来对 $x$、$\omega$、$n$ 和 $r$ 进行编码。

为此，当非线性的尺度与“blob”的大小在同一数量级时，单blob编码 [Müller 等人 2019] 表现良好。这对于 $\omega$、$n$ 和 $r$ 是一个很好的选择，因为这些参数的微小变化通常不会显著改变散射辐射度。因此，我们使用非常少的（例如 $k = 4$）均匀分布的blob来对它们进行编码。

然而，位置 $x$ 的微小变化可能会导致散射辐射度的大幅变化，例如在阴影和几何边界处，或者在比视锥体大得多的户外环境中。因此，单blob编码不适合在仅增加少量额外维度的情况下稳健地对位置进行编码。相反，我们采用了来自Transformer网络的频率编码 [Vaswani 等人 2017]，由Mildenhall 等人 [2020] 引入到辐射度学习中，它利用周期函数的几何层次结构，在少量编码维度中表示高动态范围的值。

我们使用12个正弦函数，每个函数的频率为 $2^d$，其中 $d \in \{0, \dots, 11\}$。为了节省维度，我们发现省略原始方法中的余弦项并不会影响近似质量。总的来说，我们神经网络的输入是以下内容的连接：频率编码的位置 $x$、单blob编码的参数 $\omega$、$n$ 和 $r$，以及原始的漫反射率 $\alpha$ 和镜面反射率 $\beta$；详细的分解请参见表1。这使得神经网络的输入维度总数为62，为了与硬件矩阵乘法加速器兼容，我们将输入填充到64。我们用值1进行填充，这使得网络能够隐式地学习一个偏置项（第一权重矩阵的相应列），尽管我们的架构中没有明确的偏置项。


# 4 全融合神经网络

我们从头开始用GPU编程语言实现我们的神经网络，以充分利用GPU的内存层次结构。在图7中，我们将这种实现与TensorFlow（v2.5.0）[Abadi等人 2015]进行了性能比较，我们的实现比TensorFlow快了近一个数量级。

为了理解这种显著加速的来源，我们考察了评估像我们这样的全连接神经网络的瓶颈。这种神经网络的计算成本与其宽度呈二次方关系，而其内存流量呈线性关系。现代GPU的计算吞吐量远远大于其内存带宽，这意味着对于像我们这样较窄的神经网络，线性内存流量是瓶颈。因此，提高性能的关键是尽量减少对慢速“全局”内存（显存和高级缓存）的访问，并充分利用快速的片上内存（低级缓存、“共享”内存和寄存器）。

我们的全融合方法正是这样做的：我们将整个神经网络实现为一个单独的GPU内核，该内核设计得只有读取和写入网络输入和输出的操作才会访问慢速全局内存。此外，从头开始实现内核，而不是使用现有的框架来构建它，使我们能够根据我们使用的网络架构和GPU来专门定制实现。

图6展示了全融合方法是如何映射到内存层次结构的。使用CUDA术语：给定的一批输入向量被分割成块列段，每个块列段由一个线程块独立处理（图6(b)）。线程块通过交替执行权重矩阵乘法和逐元素应用激活函数来独立评估网络。通过使线程块足够小，使得所有中间神经元的激活都能放入片上共享内存，从而将对慢速全局内存的访问降到最低。这是全融合方法的关键优势，与典型的通用矩阵乘法实现形成对比。

在矩阵乘法中（图6(c)），线程块中的每个warp计算单个块行（条纹区域）的矩阵乘积。在我们的情况下，$W_i$中的条纹权重足够少，可以放入warp的寄存器中，因此可以重复用于warp计算的每个$H'_{i+1}$块，从而获得额外的性能提升。此外，由于每个warp加载权重矩阵的不同块行，整个线程块从全局内存中加载权重矩阵恰好一次，这不能再减少。因此，唯一可能进一步减少全局内存流量的方法是通过使线程块尽可能大，以适应共享内存，从而减少线程块的数量。在我们的硬件（NVIDIA RTX 3090）和64个神经元宽的网络上，当每个线程块处理一批中的128个元素时，达到了这个最佳点。因此，每个线程块计算一个64×64权重矩阵与数据的64×128块的矩阵乘积。

**训练全融合神经网络。**对于训练，前向和反向传播的矩阵乘法结构与前面讨论的推理传递相同。然而，它们需要额外的全局内存流量，因为中间激活及其梯度必须写入以用于反向传播。此外，还需要额外的矩阵乘法，将反向传播的结果转换为权重矩阵的梯度。我们使用CUTLASS模板库（在split-k模式下）的通用矩阵乘法（GEMM）例程来计算这些额外的矩阵乘法，因为我们无法自己产生更快的实现。

所有这些额外的操作使得训练比推理慢大约4到5倍；见图7。


## 5 实际考虑

### 架构
我们的全融合神经网络架构（见图6）包含七个全连接层。五个隐藏层各有64个神经元，使用ReLU激活函数。输出层将64维数据缩减为三个RGB值。所有层均未使用偏置向量，因为偏置并未带来任何可测量的质量提升，而省略它们可以使全融合实现更简单、更高效。需要注意的是，该神经网络足够浅，不会出现梯度消失的问题。因此，无需使用带有跳跃连接的残差层来辅助训练，这一点我们已经通过实验验证。

### 反射率分解
为了提高纹理颜色的再现效果，我们将网络输出乘以漫反射率和镜面反射率之和，即 $\alpha(x, \omega) + \beta(x, \omega)$。对于朗伯体材料，这相当于辐照度分解 [Ward等人 1988]，网络实际上被赋予了学习辐照度而非反射辐射度的任务。然而，即使在我们高度非朗伯体的场景中，上述分解也是有益的。这种分解并非用于恢复细节——$\alpha(x, \omega)$ 和 $\beta(x, \omega)$ 本身已经是网络的输入——但它有助于恢复颜色，同时让缓存专注于补充细节（见图8）。

### 高性能编码原语
单blob和频率编码依赖于计算成本较高的原语：高斯核和三角函数。因此，我们用评估成本远低于原函数的近似值来替代这些原语。具体来说，我们将高斯核替换为四次核，将正弦函数替换为三角波（见图9），每帧成本降低了0.25毫秒，且没有明显的质量损失。

### 相对损失
为了实现有效的训练，我们使用相对$L_2$损失，当训练信号——反射辐射度$L_s(x, \omega)$——存在噪声时，它能够提供无偏的梯度估计 [Lehtinen等人 2018]。损失通过神经网络的预测值进行归一化：

$$
L^2 \left( L_s(x, \omega), \hat{L}_{s}(x, \omega; W_t) \right) := \frac{\left( L_s(x, \omega) - \hat{L}_{s}(x, \omega; W_t) \right)^2}{\text{sg} \left( \left( \hat{L}_{s}(x, \omega; W_t) \right)^2 + \varepsilon \right)}, \quad (5)
$$

其中，$\varepsilon = 0.01$，$\text{sg}(\cdot)$表示在优化过程中将其参数视为常数，即不向后传播梯度。此外，对于$L_s(x, \omega)$的光谱值，我们通过光谱范围内的平方亮度对每个颜色通道的损失进行归一化。

### 优化器

优化器的选择对于充分利用每帧有限的训练数据至关重要。为此，我们比较了多种一阶优化器，即随机梯度下降（SGD）、Adam [Kingma和Ba 2014]和Novograd [Ginsburg等人 2019]，发现Adam在迭代次数最少的同时，实际上几乎没有额外开销。

我们还研究了一种二阶优化器Shampoo [Anil等人 2020; Gupta等人 2018]，它比Adam的收敛迭代次数略少。然而，我们优化实现的每帧0.3毫秒的开销在实验中并未证明其优势，因此我们在所有结果中均使用Adam。

## 6 结果与讨论

我们使用CUDA实现了神经辐射缓存的所有组件，包括输入编码、全融合网络和优化器，其源代码我们已公开发布 [Müller 2021]。我们将辐射缓存集成到使用Falcor渲染框架 [Benty等人 2020] 实现的Direct3D 12路径追踪器中，本文中所有结果均由此生成。所有图像均在高端桌面机器（i9 9900k和RTX 3090）上以1920×1080的分辨率渲染而成。对于每张图像，我们报告平均相对平方误差（MRSE）[Rousselle等人 2011]，或其分解为相对偏差（rBias）和方差（rVar），以帮助读者衡量改进的蒙特卡洛效率。如适用，我们还列出基于感知的FLIP度量 [Andersson等人 2020]，该度量对离群值（“萤火虫”）更具鲁棒性。我们的参考图像是使用启用ReSTIR的路径追踪生成的，以确保我们只测量由辐射缓存引起的偏差，而不是ReSTIR的偏差。

### 实时渲染
在图10中，我们利用神经辐射缓存（NRC）来减少路径追踪器的间接光照噪声。通过将NRC与互补的直接光照技术相结合，我们实现了低噪声且偏差较小的实时全局光照。我们的基线是一个带有俄罗斯轮盘赌和由光BVH [Moreau等人 2019] 驱动的下一次事件估计的无偏路径追踪器，我们在此基础上增加了屏幕空间时空重采样（ReSTIR）[Bitterli等人 2020]。尽管该算法在直接光照估计（PT+ReSTIR列）中具有较低的方差，但它在间接光照估计中存在噪声，这可以通过将路径终止到我们的缓存中来解决（PT+ReSTIR+NRC列）。以这种方式缩短路径不仅降低了方差，而且有时由于查询和训练全融合网络的开销较低，还会导致更高的帧率。

与路径追踪相比，ReSTIR和NRC的结合将MRSE降低了1到2个数量级，同时对性能的影响相对较小。在所有场景中，结合的技术均超过了每秒60帧。我们在表2中通过让基线收敛到与我们方法的一帧渲染相等的MRSE来衡量我们的加速比。测试场景的平均加速比为13.6倍。

### 自训练
我们比较了自训练与依赖纯路径追踪的训练的性能。使用我们的路径终止启发式方法终止训练路径，我们将尾部贡献设置为黑色（路径追踪训练）或最后一个顶点的辐射预测（自训练）。如图11所示，自训练解决方案准确地捕捉了多反弹光传输。自训练的计算开销相当于为每条少数训练路径额外查询一次辐射缓存的成本，大约占总开销的1%——与不追踪更长路径以学习全局光照所节省的成本相比，这是一个很小的数目。

### 缓存质量
在图12中，我们通过在第一个非镜面顶点处可视化缓存来研究神经辐射缓存的质量。由于对底层场景的材质和几何形状不敏感，缓存能够处理广泛的视觉现象。例如，它处理了“Zero Day”场景中的复杂光泽传输、“Bistro”场景中的远距离阴影细节，以及“Attic”场景中的薄几何形状且无漏光现象，如遮阳篷。缓存还擅长捕捉每个场景中几乎所有区域的整体颜色。

缓存的局限性有两个方面。首先，如果细节未出现在网络输入中（例如锐利的接触阴影或焦散），缓存则无法很好地捕捉锐利细节。其次，缓存表现出微妙的轴对齐条纹，这是频率编码的副产品 [Mildenhall等人 2020]。由于我们依赖频率编码来处理大规模的空间细节（例如“Bistro”场景中的准确远距离阴影），我们不能简单地切换到不同的编码。我们尝试过的所有其他编码要么表现出更严重的伪影，要么无法很好地扩展。

因此，为了掩盖剩余的缓存不准确之处，我们根据第3.4节中的终止启发式方法延迟其评估。由于启发式方法基于路径足迹，因此缓存伪影通过粗糙反射被观察到，并因此被平均化。启发式方法还导致在凹陷处的缓存查询次数减少，接触阴影的不准确之处可能会成为问题。图12中的插图证实了这一观察结果：与终止启发式方法结合使用时，缓存生成的图像在视觉和数值上都难以与真实图像区分开来。

**图 10.** 我们展示了神经辐射缓存（NRC）在1样本每像素（1 spp）实时渲染中的优势，这些场景具有不同的材质和光照复杂性。从左到右：我们的基线是带有俄罗斯轮盘赌和由光BVH [Moreau等人 2019] 驱动的下一次事件估计的无偏路径追踪。然后，我们增加了时空重采样（ReSTIR）[Bitterli等人 2020] 以实现低方差的直接光照，以及NRC以实现低方差的间接光照。单独来看，这些互补技术在各自领域表现出色（例如，ReSTIR在直接光照的Bistro场景中，NRC在光泽的Zero Day场景中），但它们的组合带来了最大的改进。这三种技术结合在一起，将路径追踪的平均相对平方误差（MRSE）降低了1到2个数量级，而由于NRC大幅缩短了路径，性能损失相对较小。在所有场景中，结合的技术在1920×1080的分辨率下均超过了每秒60帧。我们还报告了基于感知的FLIP度量，它对离群值（“萤火虫”）更具鲁棒性。


**与动态漫反射全局光照（DDGI）的比较。** 在图13中，我们将神经缓存与DDGI [Majercik等人 2019] 进行了比较。DDGI是辐照度探针的现代扩展，依赖于表面法线和反照率的调制来近似散射辐射度。因此，DDGI最适合于朗伯体材料，这也是为什么我们展示了使用朗伯体漫反射BSDF模型以及更物理基础的Frostbite模型 [Lagarde和de Rousiers 2014] 的结果，我们的场景就是用后者建模的。

DDGI为了性能和低噪声做出了激进的权衡：路径在其第一次漫反射交互时终止于辐照度探针（而不是光泽或镜面反射），这通常是主顶点。因此，DDGI一方面非常高效（路径短）且噪声小，但另一方面缺乏环境遮挡，并且由于其有限的空间分辨率，可能会暴露出可见的偏差（例如在粉色房间中）。

与DDGI相反，我们使用NRC做出了相反的权衡。我们以略微降低性能和（有时更多）噪声为代价，尽量减少偏差。与DDGI不同，我们的神经表示对底层材质模型不做任何假设，并且我们的路径终止标准有助于避免NRC的剩余不准确之处，同时也能恢复环境遮挡。因此，我们模型的较高成本可以通过DDGI所需的单独环境遮挡通道的成本来抵消。

**性能分析。** 在表3中，我们更详细地分析了DDGI和NRC所花费的时间。我们将渲染成本分解为（i）路径追踪和着色，（ii）查询缓存/DDGI，以及（iii）训练缓存/DDGI。

与PT+ReSTIR基线相比，DDGI和NRC的低路径追踪成本源于追踪的光线较少：除了俄罗斯轮盘赌之外，DDGI在其采样漫反射lobe时终止路径，NRC则根据其足迹终止每条路径。平均而言，这两种方法都大致将路径追踪的成本降低了大约2.8毫秒/帧（25%）。然而，这种改进部分被查询和训练或更新各自缓存的开销所抵消。

正如预期的那样，查询DDGI比查询我们的神经网络更快。然而，考虑到神经网络通常被认为成本高昂，实际差异比预期的要小：全帧DDGI查询平均耗时0.58毫秒，而神经辐射缓存耗时1.59毫秒。这两种方法在实时设置中的成本都在合理范围内。最有趣的是，训练神经辐射缓存的成本低于训练DDGI体积的成本（平均1.11毫秒对比1.37毫秒）。

这有两个原因。首先，NRC非常数据高效，每帧仅使用 $2^{16} = 65536$ 条训练记录。另一方面，DDGI在我们的 $16 \times 16 \times 16$ 探针网格配置中，每帧追踪 $16^3 \times 256 = 1048576$ 条更新光线——比NRC多出10倍以上。其次，为NRC追踪的少量训练路径与其需要为渲染追踪的路径共享前几个顶点，进一步节省了成本。


## 7 讨论与未来工作

### 预计算
虽然我们没有进行任何预计算，但可以通过例如预训练神经网络的良好初始状态或利用低开销的元学习技术 [Hospedales等人 2020] 来引入预计算。在我们的设计中，我们将预计算视为严格可选的，仅在可能的情况下增强性能。事实上，由于神经辐射缓存能够迅速学习当前情况（8帧就足够了，见图4），预计算只能带来有限的好处。尽管如此，探索静态神经网络权重集的效用以及确定固定神经网络权重集的有效性范围仍然是有意义的。

### 缓存伪影
尽管我们通过在优化的网络权重上使用指数移动平均值成功抑制了高频时间闪烁，但仍存在微妙的低频闪烁。此外，频率编码会在空间中引起令人分心的轴对齐振荡。这些伪影在非主路径顶点处使用神经辐射缓存时是不可察觉的，但在某些用例中（例如，当不能容忍噪声时），在主顶点处使用缓存是可取的。因此，未来的工作需要以一种视觉上令人愉悦的方式稳定预测。

### 额外的网络输入
仅靠输入编码不足以学习与所有网络输入相关性差的散射辐射度的详细、高频表示。例如，阴影和焦散与我们可以轻松传递给网络的局部表面属性无关。因此，阴影和焦散的学习速度要慢得多——或者如果网络太小或辐射度估计太嘈杂，就根本学不到。因此，思考与这些特征相关性好的额外、易于计算的网络输入是非常有趣的。

### 离线渲染
尽管我们的神经缓存设计专注于实时渲染，但我们相信其自训练的使用在离线场景中也会有益。事实上，它允许在不进行长路径的昂贵追踪和着色的情况下捕获高阶间接光照；这可能特别有助于解决批量渲染的路径长度限制 [Burley等人 2018]。

### 体积渲染
我们注意到，我们的神经缓存参数化并不依赖于表面表示，因此也可以用于体积渲染。直接实现的结果很有希望（见图14），但需要进行深入调查。

### 路径引导
我们结果中的主要噪声来源是对缓存的间接使用。尽管这种间接性导致偏差减少，但由于（半）球形采样，它也导致方差增加，即使缓存近似本身是无噪声的。可以考虑将神经重要性采样 [Müller等人 2019] 引入实时应用；与我们的神经辐射缓存一样，其成本乍一看似乎过高，但应用类似的原则可能会取得成功。

### 改进的路径终止
可以使用更准确的各向异性面积扩散近似，例如协方差追踪 [Belcour等人 2013] 或束一致性 [Meng等人 2015]。尽管我们没有遇到Bekaert等人各向同性近似的特定失败模式，但具有强烈各向异性光照效果的场景可能会从上述方法中受益。

除了面积扩散近似的选择之外，另一个挑战是长的、分支的、镜面反射的交互链中缺乏路径终止。因此，当传输主要由玻璃等介质材料主导时，我们的缓存目前提供的好处很少，如图15所示。在这种情况下改进终止启发式方法，以及提供更准确的缓存以解决锐利的镜面细节，是非常有意义的。

### 去噪
我们的神经辐射缓存可以被视为路径空间去噪器，因为它有效地对时空样本进行回归以产生无噪声的近似值。在图16中，我们展示了这种路径空间去噪与现有的屏幕空间技术是互补的。这个初步实验使用了一个现成的去噪器，该去噪器是在与我们的方法不具代表性的数据上训练的，因此我们期望我们的缓存与去噪器的更紧密耦合可能会带来进一步改进的潜力。

## 8 结论
我们介绍了一种用于路径追踪全局光照的实时神经辐射缓存技术。它能够处理动态内容，同时提供可预测的性能和资源消耗，这得益于我们实现泛化的全融合神经网络，它们通过在线适应来实现。尽管所需的性能需要大量的工程实现，但鲁棒性也随之而来。最终的高质量渲染效果弥补了神经辐射缓存的成本，并且可以通过正交的方差降低技术（例如路径引导）进一步改进。

神经辐射缓存是一种与以往技术截然不同的实时渲染方法。它可以被描述为在计算上“浪费”——一些神经元对输出的影响很小，但它们的贡献仍然被计算。相比之下，具有复杂数据结构的竞争技术可以被描述为在内存上“浪费”——内存从未被充分利用，因为查询只访问小的（随机的）邻域。神经辐射缓存利用固定功能硬件（GPU张量核心），并且严重依赖廉价的计算，而不是昂贵的内存访问。这种效率在表3的时间数据中得到了体现，尽管我们的神经方法需要相对大量的计算（两种实现都经过了合理的优化），但其成本仅是辐照度探针的两倍。我们主张这种计算效率是神经缓存鲁棒性的关键因素。这种范式——廉价计算——似乎值得进一步研究 [Dally等人 2020]，我们希望它能激发在计算通常被视为珍贵资源的应用中的进一步实验。

# Q&A

## 图片中的噪点

User: 我没有看太懂，为什么论文里面的某些展示的Ours图片上包含很多噪声点，另一些图片中没有噪声点呢？
Kimi: 这是一个很好的问题！论文中展示的“Ours”图片（即使用神经辐射缓存技术渲染的图像）在某些情况下存在噪声点，而在其他情况下没有噪声点，这主要是由于以下几个因素导致的：

### 1. **路径追踪的随机性**
路径追踪是一种基于蒙特卡洛方法的渲染技术，它通过随机采样来估计光线在场景中的传播。由于采样是随机的，因此在某些像素上可能会出现“噪声点”（也称为“fireflies”），这些点通常是由于少数异常高的采样值导致的。即使使用了神经辐射缓存技术，路径追踪的随机性仍然存在，因此在某些情况下仍然可以看到这些噪声点。

### 2. **神经辐射缓存的局限性**
神经辐射缓存技术虽然能够显著减少噪声，但它并不是完美的。神经网络的近似可能会引入一些偏差，尤其是在处理复杂场景时。例如：
- **高频细节**：神经网络可能难以准确捕捉到场景中的高频细节（如锐利的阴影或焦散），因此在这些区域可能会出现噪声点。
- **训练不足**：如果神经网络的训练时间不足，或者训练数据不够丰富，网络可能无法准确学习到场景中的光照模式，从而导致噪声点的出现。
- **路径终止策略**：论文中提到的路径终止策略（基于路径扩散面积的启发式方法）虽然能够减少计算量，但可能在某些情况下不够精确，导致路径在不合适的时机终止，从而引入噪声。

### 3. **不同的场景和设置**
不同的场景和渲染设置也会影响噪声点的出现：
- **复杂的材质和灯光**：某些场景可能包含复杂的材质（如高反射率的镜面材质）或复杂的灯光设置（如多个光源或复杂的阴影），这些都会增加噪声点出现的可能性。
- **采样率**：论文中提到的实验中，某些场景使用了更高的采样率（如 32 spp 或 64 spp），这可以减少噪声点的出现。而在 1 spp（每像素一个采样）的情况下，噪声点更容易出现。
- **训练时间**：在某些实验中，神经网络可能需要更多的时间来适应场景的变化。如果训练时间不足，网络可能无法有效地减少噪声。

### 4. **对比方法的影响**
论文中还展示了与其他方法（如 ReSTIR、DDGI 等）结合使用的结果。这些方法在某些情况下可以进一步减少噪声点：
- **ReSTIR**：ReSTIR 是一种用于直接照明降噪的技术，可以显著减少直接光照的噪声。当与神经辐射缓存结合使用时，可以更好地处理直接和间接照明的噪声。
- **DDGI**：DDGI 是一种动态全局光照技术，虽然在某些情况下可能引入偏差，但通常能够提供更平滑的结果。与神经辐射缓存相比，DDGI 在某些场景中可能表现更好，尤其是在处理高频细节时。

### 5. **实验结果的展示**
论文中展示的图像通常是经过优化的，以突出神经辐射缓存技术的优势。在某些情况下，作者可能选择了特定的场景或设置来展示技术的效果。例如：
- **低采样率**：在 1 spp 的情况下，神经辐射缓存技术仍然能够显著减少噪声，但可能无法完全消除噪声点。
- **高采样率**：在更高的采样率（如 32 spp 或 64 spp）下，噪声点会显著减少，但计算成本也会增加。

### 总结
论文中展示的“Ours”图片中存在噪声点的原因主要有以下几点：
1. **路径追踪的随机性**：路径追踪的随机采样可能导致噪声点的出现。
2. **神经辐射缓存的局限性**：神经网络的近似可能不够精确，尤其是在处理复杂场景时。
3. **不同的场景和设置**：复杂的材质、灯光设置和较低的采样率都可能导致噪声点的出现。
4. **对比方法的影响**：与其他降噪技术结合使用时，可以进一步减少噪声点。

尽管如此，神经辐射缓存技术在实时渲染中仍然表现出色，能够在保持较高帧率的同时显著减少噪声，为动态场景的实时渲染提供了一种有效的解决方案。
