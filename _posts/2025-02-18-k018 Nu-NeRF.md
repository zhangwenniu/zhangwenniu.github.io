---
layout: mypost
title: k018 Nu-NeRF, Neural Reconstruction of Nested Transparent Objects with Uncontrolled Capture Environment
categories: [透明, SDF, 表面重建]
---

如果有研究透明场景3D重建的研究者，可以通过邮箱zhangwenniu@163.com联系我，我目前创建了一个透明场景3D重建的研究者交流群，欢迎感兴趣的研究者加入。

# 链接

- [论文链接](https://drive.google.com/drive/folders/1DP_aQ5GRow-Se4LpImYLjX3mah2__PSh?usp=sharing)

- [主页](http://geometrylearning.com/NU-NeRF/)

- [github](https://github.com/78ij/NU-NeRF)

论文引用

```bibtex
@inproceedings {NU-NeRF,
    author = {Jia-Mu Sun and Tong Wu and Ling-qI Yan and Lin Gao},
    title = {NU-NeRF: Neural Reconstruction of Nested Transparent Objects with Uncontrolled Capture Environment},
    journal = {ACM Transactions on Graphics(ACM SIGGRAPH Asia 2024)},
    year = {2024}
}
```


# 论文重点和难点部分讲解

## 论文重点

1. **问题背景与动机**
   - 透明物体的几何重建是一个极具挑战性的问题，因为光线在透明物体表面会发生折射和反射，导致复杂的光路变化。现有的方法通常依赖于特殊的捕获设备（如偏振相机）、特殊的背景图案或额外的输入（如物体掩码），这限制了它们在实际场景中的应用。
   - 本文提出了一种名为 **NU-NeRF** 的方法，能够在**无控制的捕获环境**下重建嵌套透明物体的几何结构，无需额外输入或特殊设备。

2. **方法概述**
   - NU-NeRF 基于 **神经符号距离场（SDF）** 和神经渲染技术，分为两个主要阶段：
     1. **外表面重建**：通过分离表面颜色为反射和折射部分，利用物理基础的材料模型和渲染方法重建外表面。
     2. **内表面重建**：使用显式的光线追踪技术在外表面内部重建内表面，支持多种材料组合。
   - 该方法能够处理复杂的嵌套透明物体，例如装有水的塑料瓶，并重建其内外表面。

3. **技术创新点**
   - 提出了一种新的透明界面公式，用于处理不同类型的透明表面。
   - 引入了基于光线追踪的迭代重建策略，能够逐层重建嵌套表面。
   - 在实验中，NU-NeRF 在合成和真实场景上均优于现有方法，尤其是在无需额外输入的情况下。

4. **实验结果**
   - 在合成数据集和真实数据集上的实验表明，NU-NeRF 能够准确重建外表面和内表面的几何结构，并在复杂场景中表现出色。
   - 与现有方法（如 NeMTO 和 Li et al.）相比，NU-NeRF 在嵌套透明物体的重建中表现出更高的精度和细节。

## 论文难点

1. **折射建模的复杂性**
   - 透明物体的折射建模是本文的核心难点之一。折射光线的方向和强度会因物体的折射率（IoR）和表面几何形状而发生显著变化。直接使用显式的光线追踪方法需要已知的表面几何，但在训练阶段，表面几何是未知的。
   - **解决方案**：作者引入了一个基于 MLP 的简单而有效的折射建模方法，将折射方向和观察方向作为输入，预测折射光的颜色。尽管 MLP 无法完美建模折射光，但它可以补偿反射分量与观察颜色之间的残差，从而实现高质量的重建。

2. **无控制环境下的重建**
   - 在无控制的捕获环境中，输入图像可能包含复杂的背景、光照条件和噪声，这增加了重建的难度。
   - **解决方案**：NU-NeRF 通过神经渲染技术，利用 SDF 表示来实现高保真的表面重建，并引入了一种新的损失函数（如入射光一致性损失 $\ell_{\text{light}}$），以提高重建的精度和细节。

3. **嵌套表面的迭代重建**
   - 对于嵌套透明物体（如一个透明容器内装有其他透明或不透明物体），需要逐层重建内外表面。这要求算法能够准确处理光线在多个界面之间的传播。
   - **解决方案**：作者提出了一个“洋葱式”的迭代重建策略，通过显式的光线追踪技术在外表面内部重建内表面。该策略支持零厚度和非零厚度的界面建模，并通过引入两个折射率（$\eta_l$ 和 $\eta_r$）来处理嵌套表面。

4. **复杂光学效应的处理**
   - 透明物体的重建还需要考虑复杂的光学效应，如全内反射（Total Internal Reflection, TIR）。这些效应可能导致光线在物体内部多次反射，从而影响重建结果。
   - **解决方案**：NU-NeRF 在一定程度上通过引入非零厚度界面公式和边缘遮挡（mask erosion）技术来处理这些复杂效应，但在某些情况下（如全内反射区域）仍可能无法完美重建。

## 总结

NU-NeRF 在透明物体重建领域取得了显著进展，特别是在无控制捕获环境下对嵌套透明物体的重建。其创新的神经渲染技术和迭代重建策略为复杂场景下的几何重建提供了新的思路。然而，该方法在处理复杂光学效应（如全内反射）和多层嵌套表面时仍存在局限性，这为未来的研究提供了新的方向。


# 论文详细解读

NU-NeRF —— Neural Reconstruction of Nested Transparent Objects with Uncontrolled Capture Environment

## 1. 论文背景与动机

透明物体的几何重建是计算机视觉和图形学中的一个经典难题。由于透明物体表面的折射和反射效应，光线路径复杂且难以追踪，导致重建过程中存在大量歧义。现有的透明物体重建方法通常依赖于特殊的捕获设备（如偏振相机）、特殊的背景图案或额外的输入（如物体掩码、光照条件等）。这些方法虽然在特定条件下效果显著，但在实际应用中存在以下限制：

- **特殊设备或环境要求**：需要特殊的捕获设备或控制环境（如均匀光照、特定背景等）。
- **仅支持单一材料**：大多数方法只能处理具有单一折射率的固体透明物体，无法处理嵌套的透明物体（如装有水的塑料瓶）。
- **依赖额外输入**：需要物体掩码、光照条件等先验信息，难以在真实场景中直接应用。

为了解决这些问题，本文提出了一种名为 **NU-NeRF (Nested Transparent Object Reconstruction with Neural Radiance Fields)** 的方法，能够在**无控制的捕获环境**下重建嵌套透明物体的几何结构，无需额外输入或特殊设备。

## 2. 方法概述

NU-NeRF 是一种基于神经符号距离场（SDF）和神经渲染技术的透明物体重建方法。它分为两个主要阶段：

### 2.1 第一阶段：外表面重建

**目标**：重建透明物体的外表面几何结构。

**方法**：
1. **表面颜色分离**：将表面颜色分解为反射和折射两部分。
   - **反射部分**：使用基于物理的材质模型和渲染方法（如 Cook-Torrance 反射模型）来建模。
   - **折射部分**：由于折射光的复杂性，直接建模非常困难。因此，本文引入了一个多层感知机（MLP）来预测折射光的颜色。该 MLP 的输入包括光线方向和折射方向，输出为折射光的颜色。
2. **神经符号距离场（SDF）**：使用 SDF 表示物体表面，通过体积渲染技术重建外表面的几何结构。SDF 的优势在于它能够提供高保真的表面重建，同时支持高效的神经渲染。
3. **损失函数**：为了优化重建结果，本文引入了多种损失函数，包括：
   - **颜色损失**：最小化重建颜色与输入图像颜色之间的差异。
   - **Eikonal 损失**：约束 SDF 的梯度为 1，确保其表示有效的表面。
   - **入射光一致性损失**：约束 MLP 预测的入射光与背景 NeRF 的一致性，避免过拟合。

### 2.2 第二阶段：内表面重建

**目标**：在外表面内部重建嵌套的内表面几何结构。

**方法**：
1. **光线追踪**：在外表面内部进行光线追踪，模拟光线在透明物体中的传播路径。通过显式的光线追踪技术，确保光线与外表面的交互被准确模拟。
2. **迭代重建策略**：采用“洋葱式”迭代策略，逐层重建嵌套表面。
   - **零厚度界面**：对于非常薄的界面（如玻璃容器），假设光线在界面内外的折射方向一致，使用两个折射率（$\eta_l$ 和 $\eta_r$）分别表示界面材料和内部物质的折射率。
   - **非零厚度界面**：对于较厚的界面，引入额外的厚度参数 $h$，并使用局部球形近似来计算光线在界面内的传播路径。
3. **内表面重建**：在光线追踪的基础上，再次使用 SDF 表示和神经渲染技术重建内表面几何结构。

## 3. 关键技术细节

### 3.1 表面颜色建模

透明物体的表面颜色由反射和折射两部分组成。反射部分可以通过物理基础的渲染模型（如 Cook-Torrance 模型）直接建模，而折射部分则通过 MLP 预测。具体公式如下：

$$
c = (1 - \alpha)(c_{\text{refl}} + \alpha_{\text{refl}} \cdot L_{\text{refl}}) + \alpha(1 - F_{\text{fresnel}}) \cdot L_{\text{refr}} + \alpha F_{\text{fresnel}} L_{\text{refl}}
$$

其中：
- $c_{\text{refl}}$ 和 $L_{\text{refl}}$ 分别表示反射颜色和反射光。
- $L_{\text{refr}}$ 表示 MLP 预测的折射光。
- $F_{\text{fresnel}}$ 是菲涅尔反射系数，用于控制反射和折射的比例。
- $\alpha$ 是透明度参数，用于插值透明和反射材质。

### 3.2 神经符号距离场（SDF）

SDF 是一种隐式表示方法，通过预测空间中每个点到最近表面的距离来表示几何结构。与传统的体积密度表示（如 NeRF）相比，SDF 能够提供更精确的表面重建。SDF 的密度值可以通过以下公式计算：


$$
\sigma_i = \max\left(-\frac{d}{dt} \Phi_s[s(t)], 0\right)
$$

其中，$t$ 是相机原点到采样点的距离，$\Phi_s(x) = \frac{1}{1 + e^{-zx}}$，$z$ 是一个可训练的参数。

### 3.3 光线追踪与迭代重建

光线追踪是第二阶段的核心技术，用于模拟光线在外表面内部的传播路径。对于非零厚度的界面，光线在进入和离开界面时会发生两次折射。本文通过引入局部球形近似来计算光线在界面内的传播路径，并使用两个折射率来建模界面和内部物质的光学特性。

迭代重建策略类似于“剥洋葱”，逐层重建嵌套表面。具体步骤如下：
1. 重建外表面几何结构。
2. 将外表面固定为透明界面，使用光线追踪技术在外表面内部重建内表面。
3. 重复上述步骤，直到重建所有嵌套表面。

## 4. 实验结果

### 4.1 合成数据集

实验使用了多种合成数据集，包括固体透明物体（如 Pig 和 Monkey）、嵌套透明物体（如 PlasticWater 和 GlassWater）以及复杂组合物体（如 GlassIce）。实验结果表明，NU-NeRF 能够在无额外输入的情况下重建高质量的外表面和内表面几何结构，显著优于现有方法（如 NeMTO 和 Li et al.）。


| Scenes | Ours (Outer) - CD↓ | Ours (Outer) - EMD↓ | NeMTO [Wang et al. 2023] - CD↓ | NeMTO [Wang et al. 2023] - EMD↓ | Li et al. [2020] - CD↓ | Li et al. [2020] - EMD↓ | Ours (Inner) - CD↓ | Ours (Inner) - EMD↓ |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| Pig | 0.73 | 6.31 | 1.16 | 4.25 | 5.57 | 22.6 | N/A | N/A |
| Monkey | 1.02 | 4.80 | 1.43 | 11.6 | 8.56 | 76.3 | N/A | N/A |
| SpherePot | 0.99 | 3.75 | 2.41 | 8.27 | 5.50 | 8.38 | 1.32 | 3.27 |
| PlasticWater | 1.67 | 55.0 | 3.79 | 62.3 | 21.8 | 91.3 | 1.64 | 0.92 |
| GlassWater | 0.61 | 14.8 | 4.09 | 15.6 | 5.89 | 17.4 | 1.11 | 1.52 |
| GlassIce | 1.62 | 28.6 | 68.1 | 28.8 | 48.3 | 32.0 | 1.48 | 4.42 | 

### 4.2 真实数据集

实验还使用了多种真实数据集，包括 Ball、Glass、WineGlass、Lamp 和 PlasticBottle 等。这些数据集包含复杂的背景、光照条件和噪声。实验结果表明，NU-NeRF 能够在无控制的捕获环境下重建高质量的外表面和内表面几何结构，而现有方法则难以处理嵌套透明物体。

| Scenes | Ours (Outer) - CD↓ | Ours (Outer) - EMD↓ | NeMTO [Wang et al. 2023] - CD↓ | NeMTO [Wang et al. 2023] - EMD↓ | Li et al. [2020] - CD↓ | Li et al. [2020] - EMD↓ | Ours (Inner) - CD↓ | Ours (Inner) - EMD↓ |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| BallStatue | 3.02 | 25.5 | 24.4 | 59.3 | 13.1 | 89.3 | 0.94 | 8.66 |
| Bottle | 4.57 | 6.78 | 48.0 | 50.1 | 37.1 | 48.2 | N/A | N/A |
| Bottle2 | 3.34 | 27.1 | 15.7 | 74.2 | 21.7 | 126.9 | N/A | N/A | 


## 5. 论文贡献

NU-NeRF 的主要贡献包括：
1. 提出了一种能够在无控制捕获环境下重建嵌套透明物体的方法，无需额外输入或特殊设备。
2. 引入了一种新的透明界面公式，能够处理不同类型的透明表面。
3. 提出了一种基于光线追踪的迭代重建策略，能够逐层重建嵌套表面。
4. 在合成和真实数据集上的实验结果表明，NU-NeRF 显著优于现有方法，能够重建高质量的外表面和内表面几何结构。

## 6. 局限性与未来工作

尽管 NU-NeRF 在透明物体重建领域取得了显著进展，但仍存在一些局限性：
1. **复杂光学效应**：NU-NeRF 无法完全处理复杂的光学效应，如全内反射（TIR）。
2. **多层嵌套表面**：虽然理论上可以处理多层嵌套表面，但目前的实现仅支持两层表面。
3. **真实场景中的噪声**：在真实场景中，输入图像可能包含噪声、光照不均匀等问题，这会影响重建结果的精度。

未来的工作方向包括：
1. 进一步改进光学效应的建模，以处理全内反射等复杂现象。
2. 扩展方法以支持更多层的嵌套表面重建。
3. 提高方法对真实场景中噪声和光照变化的鲁棒性。

## 7. 总结

NU-NeRF 是一种创新的透明物体重建方法，能够在无控制的捕获环境下重建嵌套透明物体的几何结构。它通过神经符号距离场和神经渲染技术，结合光线追踪和迭代重建策略，实现了高质量的外表面和内表面重建。该方法在合成和真实数据集上的实验结果表明，其性能显著优于现有方法，为透明物体重建领域提供了新的解决方案。

# 原文翻译

**NU-NeRF：无需专用捕获环境或额外输入的嵌套透明物体神经重建**

## 摘要

透明物体的几何重建是一个极具挑战性的问题，因为折射会使表面颜色发生剧烈变化且高度不连续。现有的方法依赖于特殊的捕获设备、专用背景或真实的物体掩码来提供更多的先验信息，从而减少问题的歧义性。然而，这些方法很难应用于真实生活中的重建任务，比如使用移动设备在野外场景中进行捕获。此外，这些方法只能处理固体且均匀的材料，极大地限制了它们的应用范围。

为了解决上述问题，我们提出了一种名为 **NU-NeRF** 的方法，用于在无需专用捕获环境或额外输入的情况下重建嵌套透明物体的几何结构。NU-NeRF 基于 **神经符号距离场（SDF）** 表示，并利用神经渲染技术。它包含两个主要阶段：

在第一阶段，我们将表面颜色分解为反射和折射两部分。反射部分通过基于物理的材质模型和渲染方法进行建模；而折射部分则通过一个给定折射方向和视图方向的单层 MLP（多层感知机）进行建模，这是一种简单而有效的折射建模方法。这一阶段能够生成外表面的高保真几何结构。

在第二阶段，我们在重建的外表面使用显式的光线追踪技术进行精确的光线传输模拟。在该阶段，外表面内部再次执行表面重建，以获取内表面的几何结构。在这一过程中，我们引入了一种新的透明界面公式，用于处理不同类型的透明表面。在合成场景和真实捕获场景上的实验表明，NU-NeRF 能够比现有方法更好地完成重建任务，并在无控制的捕获环境中实现精确的嵌套表面重建。

## 1 引言

透明现象在日常生活中十分常见，例如水或玻璃，因此透明物体的重建是许多下游应用的必要需求。然而，由于折射导致的复杂光线路径，计算机算法在处理透明物体重建时面临巨大挑战。光线在这一过程中可能会发生显著弯曲，从而引入固有的歧义性。因此，重建物体几何结构仍然是一个不适定问题（ill-posed problem）。

为了解决这一不适定问题，一些方法 [Huynh et al. 2010; Trifonov et al. 2006; Wetzstein et al. 2011] 利用特殊的捕获设备（如偏振相机）来获取除颜色信息之外的附加信息。随后的研究尝试放宽对捕获设备的要求，但仍需要在受控环境中（例如使用特殊设计的背景图案 [Li et al. 2023a; Lyu et al. 2020; Wu et al. 2018; Xu et al. 2022] 或放置在感兴趣物体下方的不透明平面 [Gao et al. 2023]）捕获场景，以提供折射光线与参考背景或平面交点位置的信息。还有一些方法不需要特殊的捕获设备或环境，但需要物体掩码 [Chen et al. 2023; Li et al. 2020] 或真实的光照条件 [Wang et al. 2023] 作为附加输入。此外，基于视觉的方法（如 Li et al. [2020]）需要大量的训练数据集，而训练场景与实际场景之间的领域差异难以解决。

尽管在透明物体重建方面已经做出了许多努力，但嵌套透明物体的研究相对较少。ReNeuS [Tong et al. 2023] 重建了折射界面内的不透明物体，其中给出了外表面的真实几何结构和折射率（IoR）。此外，它们还需要在均匀光照条件下捕获物体，这是一个很强的要求。Bemana et al. [2022] 利用神经辐射场学习具有变化折射率的体积，并通过数值方法计算光线路径。为了处理嵌套物体，他们使用另一个辐射场拟合内表面。这种方法可以支持变化的折射率和非均匀材料，并能产生良好的新视图合成结果，但它并不服务于几何重建的目的。因此，受控的捕获环境（特殊背景、均匀光照和不透明平面等）、附加输入（掩码、光照和外表面/IoR）以及对输入的假设（固体物体、均匀材料）限制了它们在无控制捕获环境中对嵌套透明物体几何重建的实际应用。

为了克服这些缺点，我们提出了 NU-NeRF，这是一种在无控制环境中用于嵌套透明物体几何重建的方法。NU-NeRF 基于 SDF（符号距离场）的神经隐式表示 [Mildenhall et al. 2020; Wang et al. 2021]，用于高保真的表面重建。NU-NeRF 的示例结果如图 1 所示。我们的关键观察是，尽管 MLP（多层感知机）在建模折射光时并不完全准确，但它可以补偿观察颜色与反射分量之间的剩余残差，从而产生高质量的重建结果。相比之下，以前的方法仅使用显式的光线追踪来获取折射分量，因此需要额外的知识（例如物体掩码或特殊的捕获环境）。NU-NeRF 包含两个主要阶段：

1. **外表面重建**：NU-NeRF 使用外部 NeRF 模型来建模周围环境，并根据该环境约束物体表面的反射。表面的折射使用考虑了菲涅尔效应的方向依赖 MLP 进行建模。为了应对无控制的环境，在此过程中不使用任何先验信息（例如掩码、背景和光照）。

2. **光线追踪的内表面重建**：在此阶段，采用光线追踪的重建技术以从外到内的顺序获取表面。光线追踪过程确保了光线的精确模拟，并且在物体内部重复使用表面重建公式。我们观察到，我们的方法能够处理复杂表面的重建，并支持不同类型的材料组合的外表面和内表面。

总之，我们的技术贡献包括：

- 我们提出了 NU-NeRF，这是一个在无控制环境中重建嵌套透明物体的流程。NU-NeRF 可以重建透明表面内的内透明或不透明表面，极大地扩展了其适用性。
- 我们引入了一种表面颜色分量的公式，用于在没有先验对应知识的情况下支持透明物体的重建。
- 我们提出了一种与表面重建同时执行的光线追踪迭代重建策略，并引入了一种新的界面公式，用于使用光线追踪处理嵌套表面。
- 在合成和真实场景上的实验表明，我们提出的方法比需要物体掩码的基线方法能够取得更好的结果。


## 2 相关工作

### 2.1 神经隐式表示

传统上，显式表示方法（如体素、网格或点云）被广泛应用于几何处理和渲染等领域 [Xiao et al. 2020]。近年来，神经隐式表示方法（如神经辐射场（NeRF）[Barron et al. 2021; Mildenhall et al. 2020]）逐渐受到关注，因为它们仅需要少量已知姿态的图像即可重建出几何结构。这种隐式表示方法还具有足够的灵活性，能够应用于变形 [Park et al. 2021a,b; Pumarola et al. 2021; Tretschk et al. 2021] 或生成 [Chan et al. 2022; Niemeyer and Geiger 2021; Schwarz et al. 2020] 等任务。然而，原始 NeRF 采用的基于密度的表示方法使得表面重建变得困难。这也限制了神经隐式表示在逆向渲染等任务中的进一步应用，因为这些任务高度依赖于准确的法线和表面估计。一些工作 [Boss et al. 2021; Verbin et al. 2022; Zhang et al. 2021] 尝试对 NeRF 进行分解，但它们要么不是基于物理的，要么由于表面和法线估计不准确而遭受次优的渲染质量。

为了解决这一问题，VolSDF [Yariv et al. 2021] 和 NeuS [Wang et al. 2021] 提出用符号距离场（SDF）替换密度场，从而在保留 NeRF 渲染质量的同时，实现了基于神经隐式表示的高保真表面重建。随后，更多工作致力于提高几何重建的质量 [Li et al. 2023b; Sun et al. 2022]，进一步推动了逆向渲染和编辑的准确性 [Munkberg et al. 2022; Wu et al. 2023]。最近，研究重点转向重建具有复杂视觉效果的场景。一个相关的工作，NeRO [Liu et al. 2023]，专注于在强反射存在的情况下重建几何结构和表面双向反射分布函数（BRDF），并取得了最先进的结果（SOTA）。我们进一步提出了 NU-NeRF，用于在反射之外重建具有折射效果的场景，这是一种更具挑战性的效应。

### 2.2 透明物体重建

透明物体重建是一个经典问题，已经得到了广泛研究 [Ihrke et al. 2010]。光线的多次折射可能导致歧义和奇点，从而阻碍准确重建。以往关于透明物体重建的工作通常集中在寻找对应关系，因此需要特殊的捕获设置。这些设置包括光场探测 [Wetzstein et al. 2011]、层析成像 [Trifonov et al. 2006] 和偏振捕获设备 [Huynh et al. 2010; Miyazaki and Ikeuchi 2005; Shao et al. 2022]。为了消除对特殊捕获设备的需求，一系列工作 [Morris and Kutulakos 2011; Qian et al. 2016; Wu et al. 2018] 提出使用特殊设计的背景图案来寻找对应关系。给定折射光线与屏幕背景交点的真实位置后，可以优化物体的法线和形状。DRT [Lyu et al. 2020] 进一步改进了这一流程，利用微分光线追踪、粗到细的优化和掩码约束。NeTO [Li et al. 2023a] 通过考虑多次折射来提高形状重建的质量。Xu et al. [2022] 提出使用神经网络和显式网格的混合模式来重建透明物体。Lin et al. [2023] 使用正弦图案和二进制图案作为背景，对更复杂的物体（如带有彩色液体和漫反射材料的物体）进行重建。除了背景图案外，物体掩码或环境图也被用作先验信息 [Li et al. 2020]，这些先验信息可以用来指导神经网络预测折射光线的方向，并提高重建结果的质量 [Wang et al. 2023]。还有一些方法专门解决一个略有不同的问题：重建透明表面（如水面）背后的物体以及表面本身 [Zhan et al. 2023]。

近年来，随着神经隐式表示方法的不断发展，一些基于神经辐射场的工作被提出，能够在没有特殊捕获设备、特殊设计的背景、掩码或真实环境图的情况下实现透明物体重建。Bemana et al. [2022] 提出通过学习折射率（IoR）场以及辐射度和密度来实现新视图合成，并解决了沿场的弯曲光线路径。最近，Deng et al. [2024] 利用变形网络预测光线路径，获得了逼真的新视图合成结果，但由于他们使用的是密度场而不是 SDF 作为表示方法，因此无法重建几何结构。Gao et al. [2023] 提出了一种两阶段方法，首先预测物体的多视图轮廓，然后重建放置在不透明平面上的折射物体的精确形状。该方法需要一个平面，因为它被用作几何和外观的先验信息。NeRRF [Chen et al. 2023] 使用给定的输入掩码来获取物体的形状，然后采用显式光线追踪来获取辐射度估计。

相比之下，我们提出的 NU-NeRF 消除了以往方法中使用的所有捕获设置（特殊捕获设备和特殊设计的背景）和额外输入需求（掩码和真实光照）。此外，这些提到的方法仅能重建由具有恒定折射率的材料制成的“固体和均匀”物体，且物体内部没有几何结构。相比之下，我们的方法可以处理非固体物体的输入图像，这些物体的折射率是变化的，例如半瓶水的塑料瓶。对于这类物体，NU-NeRF 可以重建外表面以及任何内表面，如水面。在接下来的部分中，我们将介绍 NU-NeRF 的两个组成部分：外表面重建（第 3 节）和光线追踪的内表面重建（第 4 节）。该流程的概述如图 2 所示。


## 3 第一阶段：外表面重建

在本节中，我们首先介绍表面重建方法，这是迭代几何重建策略中两个阶段的基础模块。首先，我们介绍神经渲染和表面重建的一些基础知识（第 3.1 节）。其次，我们详细阐述重建过程中表面传输的公式，描述了着色点的渲染过程（第 3.2 节）。最后，我们描述了优化所使用的损失函数（第 3.3 节）。

### 3.1 基础知识

**神经渲染和隐式表示**：神经隐式表示方法（如 NeRF [Mildenhall et al. 2020]）通常采用体积渲染技术，沿着射线采样离散点 $p_i$，并通过计算的权重 $w_i$ 聚合这些点的颜色 $c_i$，以获得最终颜色：

$$
C = \sum_{i=0}^{N} w_i c_i
$$

NeRF 沿射线预测密度值 $\sigma_i$，并假设场景由发射体组成，从而获得权重：

$$
w_i = \exp\left(-\sum_{j<i} \sigma_j \Delta_j\right) \left(1 - \exp(-\sigma_i \Delta_i)\right)
$$

其中，$\Delta_i$ 是两个相邻采样点之间的距离。为了提高表面重建的质量，NeuS [Wang et al. 2021] 提出预测符号距离值 $s$ 而非密度值。符号距离场（SDF）值可以通过以下公式转换为密度值：

$$
\sigma_i = \max\left(-\frac{d}{dt} \Phi_s[s(t)], 0\right)
$$

其中，$t$ 是相机原点到采样点的距离，$\Phi_s(x) = \frac{1}{1 + e^{-zx}}$，$z$ 是一个可训练的参数。在本工作中，我们采用 NeuS 的基本公式，使用 SDF 作为几何表示。我们假设物体位于单位球内，并使用一个 NeRF $g_{\text{bkgr}}(p, \omega)$ 来建模外部背景，其中 $-\omega$ 是射线的方向。

**渲染方程**：为了实现表面几何的物理正确渲染，我们遵循考虑透射而非仅反射的渲染方程 [Kajiya 1986]：

$$
c = \int_{S} f(p, \omega_{\text{in}}, \omega) L_{\text{in}}(p, \omega_{\text{in}}) |N \cdot \omega_{\text{in}}| d\omega_{\text{in}}
$$

其中，$c$ 是最终颜色，$L_{\text{in}}$ 是入射辐射度，$N$ 是表面法线，$\omega$ 是体积渲染过程中射线的反向方向。$f$ 是表面点 $p$ 的双向散射分布函数（BSDF）。

### 3.2 表面反射和透射的公式化

**材质**：如图 3 所示，为了实现基于物理的反射和透射渲染，我们将表面材质参数化为基底颜色 $a$、粗糙度 $r$、金属度 $m$、折射率（IoR）$\eta$ 和透明参数 $t$。所有这些参数均由一个多层感知机（MLP）$g_m(p)$ 预测，其输入为采样点的位置。

**BSDF 的总体公式化**：在本文的范围内，我们仅考虑近乎完美光滑表面的透射分量。因此，我们明确将表面分为“透射型”和“反射型”，并使用额外的材质参数 $t$ 在它们之间进行插值。这类似于迪士尼 BRDF [Burley 2012] 变体中使用的“金属”和“电介质”插值，本文中同时使用了这两种插值。材质公式如图 3 所示。这两种类型的材质分别由两个 BSDF 表示：$f_r$（反射材质）和 $f_t$（透射材质）。我们将 $f_r$ 定义为 Lambertian 漫反射反射率和 Cook-Torrance 镜面反射率 [Cook and Torrance 1982] 的总和，这与之前旨在进行逆向渲染的方法 [Liu et al. 2023; Zhang et al. 2022] 类似。$f_t$ 定义为完美光滑透明表面上的反射和折射颜色的总和。由于 $f_r$ 和 $f_t$ 表示的两种材质都可以反射光线，因此反射分量同时出现在 $f_r$ 和 $f_t$ 中，但它们的计算方式不同。需要注意的是，菲涅尔系数 $F_p$ 是使用法线 $N$ 计算的，这与 Cook-Torrance 反射率中使用的半角向量不同。引入额外的透明值 $t$ 用于控制材质的透明度。

$$
f_r = \frac{(1 - m)a}{\pi} + \frac{DFG}{4(\omega_{\text{in}} \cdot N)(\omega \cdot N)} \quad (2)
$$

$$
f_t = (1 - F_p)\delta(\omega - \text{Refr}(\omega_{\text{in}}, \eta, N)) + F_p \delta(\omega - \text{Refl}(\omega_{\text{in}}, N)) |N \cdot \omega_{\text{in}}| \quad (3)
$$

$$
f = (1 - t) f_r + t f_t \quad (4)
$$

其中，$a$ 是漫反射反照率，$D$、$F$ 和 $G$ 是经典的微观平面分布、菲涅尔和几何分量。它们依赖于方向 $\omega$、$\omega_{\text{in}}$、表面粗糙度 $r$ 和金属度 $m$。在公式 (2) 中，为了简化，我们省略了它们的具体公式。$\delta$ 是狄拉克函数，$\eta$ 是内外材质折射率的比值，$\text{Refr}$ 是根据斯涅尔定律计算的折射方向，$\text{Refl}$ 是完美反射方向。接下来的小节将详细介绍公式 (1)、(2)、(3) 和 (4) 在神经渲染中的应用。

**反射**：对于反射渲染，我们采用了 NeRO [Liu et al. 2023] 的基本公式，并使用了分裂求和 [Karis 2013] 近似。分裂求和是一种专门用于高效计算渲染方程（公式 (1)）的技术。它将镜面反射的积分替换为两个积分的乘积：

$$
\int_{H} \frac{DFG}{4(\omega_{\text{in}} \cdot N)} d\omega_{\text{in}} \approx \left( \int_{H} L_{\text{in}} d\omega_{\text{in}} \right) \cdot \left( \int_{H} \frac{DFG}{4(\omega \cdot N)} d\omega_{\text{in}} \right) \quad (5)
$$

其中，$H$ 是由法线向量 $N$ 定义的表面之上的半球。在公式 (5) 中，$L$ 依赖于入射光，在 Karis [2013] 的原始工作以及一些同期工作 [McAuley et al. 2012, 2013] 中，入射光根据不同的粗糙度通过与 GGX 分布卷积进行预过滤。然而，在我们的设置中，训练阶段的光照是未知的，因此原始分裂求和方法中的预过滤技术不可用。因此，我们引入了积分方向编码（IDE）技术 [Verbin et al. 2022]，以在 MLP 内部实现“过滤”。为了建模光照，我们拟合了两个 MLP：$g_{\text{far}}$ 和 $g_{\text{near}}$，分别对应于来自无限远处的入射光和由几何体自身间接反射的光。根据 NeRO [Liu et al. 2023]，材质网络 $g_m$ 为每个采样点预测了一个额外的插值因子 $s$（也称为“遮挡值”）。根据 NeRO [Liu et al. 2023] 的分析，$L$ 可以近似为：

$$
L \approx (1 - s) g_{\text{far}}(\text{IDE}(\omega_i, r)) + s g_{\text{near}}(\text{IDE}(\omega_i, r), p) \quad (6)
$$

其中，IDE 是积分方向编码 [Verbin et al. 2022]，它将光照的积分转换为方向的“积分”，显著减少了 MLP 的查询次数。作为一种特殊情况，漫反射颜色可以使用以下公式近似：

$$
c_d = \frac{a}{\pi} g_{\text{far}}(\text{IDE}(\omega_i, 1))
$$

另一方面，$M$ 仅依赖于表面材质 $a$、$r$、$m$、$\eta$ 和 $t$。菲涅尔反射率 $F$ 可以使用 Schlick 近似 [Schlick 1994] 进行近似：

$$
F \approx F_{\text{sch}} = F_0 + (1 - F_0)(1 - \omega \cdot H)^5
$$

其中，$F_0$ 是入射角为 0 时的反射率，$H$ 是半角向量：

$$
H = \frac{\omega + \omega_{\text{in}}}{\|\omega + \omega_{\text{in}}\|}
$$

在我们的设置中，$F_0 = ((1 - m) \cdot a_s + m \cdot a)$，其中 $a_s$ 是电介质的镜面颜色，可以通过以下公式计算：

$$
a_s = \left(\frac{\eta - 1}{\eta + 1}\right)^2
$$

如果我们用 $F_{\text{sch}}$ 替换 $M$ 中的 $F$，$M$ 可以分解为以下形式：

$$
M = F_0 \int_{H} DG (1 - (1 - \omega \cdot H)^5) (4\omega \cdot N) d\omega_{\text{in}} + \int_{H} DG (1 - \omega \cdot H)^5 (4\omega \cdot N) d\omega_{\text{in}} \quad (7)
$$

由于公式 (7) 中的两个积分仅依赖于两个标量参数：粗糙度 $r$ 和 $\omega \cdot N$，因此可以预先计算并存储在二维查找纹理中。因此，在渲染时，仅需要两次纹理查询即可评估 $M$。我们将这两个积分分别命名为 $F_1$ 和 $F_2$，则 $M$ 可以通过以下公式计算：

$$
M = ((1 - m) \cdot a_s + m \cdot a) \cdot F_1 + F_2 \quad (8)
$$

**透射**：由于训练阶段缺乏表面几何信息，直接使用显式光线追踪和光传输定律来建模透射分量是困难的。因此，我们选择使用一个 MLP $g_r(p, \omega, \text{Refr}(\omega, \eta, N))$ 来直接建模折射。需要注意的是，原始射线方向 $\omega$ 和折射方向都被输入到 $g_r$ 中。我们现在写出表面重建的完整公式：

$$
c = (1 - t)(c_d + L \cdot M) + t(1 - F_{\text{sch}, p})(g_r(p, \omega, \text{Refr}(\omega, \eta, N
)) + t F_{\text{sch}, p} g_l(p, \text{Refl}(\omega, N)))
$$

其中，$F_{\text{sch}, p}$ 是使用法线向量输入的 Schlick 近似：

$$
F_{\text{sch}, p} = F_0 + (1 - F_0)(1 - \omega \cdot N)^5
$$

$g_l$ 是预测的入射光，其粗糙度设置为 0：

$$
g_l(p, \omega) = (1 - s) g_{\text{far}}(\text{IDE}(\omega_i, 0)) + s g_{\text{near}}(\text{IDE}(\omega_i, 0), p)
$$

根据我们的观察，由于折射的高度非连续性和快速变化特性，$g_r$ 无法准确预测折射颜色，导致渲染颜色模糊（请参见图 2）。然而，$g_r$ 可以通过在位置和方向之间提供平均值来极大地补偿反射颜色，从而实现高保真重建。如果未应用 $g_r$，几何结构将遭受显著退化，或者该方法将无法重建任何有意义的几何结构（请参见第 5.5 节）。

### 3.3 优化损失函数

在本节中，我们将介绍表面重建过程中使用的优化损失函数。首先，我们采用了 NeRO [Liu et al. 2023] 中第一阶段重建中使用的所有损失函数，包括 $l_{\text{render}}$、$l_{\text{eikonal}}$、$l_{\text{occ}}$ 和 $l_{\text{stable}}$。

- **$l_{\text{render}}$**：这是渲染颜色与输入图像像素颜色之间的 Charbonier 损失 [Charbonnier et al. 1994]。
- **$l_{\text{eikonal}}$**：这是 Eikonal 损失，用于将符号距离场（SDF）的梯度正则化为 1，如 NeuS [Wang et al. 2021] 中所应用的。
- **$l_{\text{occ}}$**：这是遮挡损失，鼓励遮挡值 $s$ 与光线追踪的真值 $s_{\text{march}}$ 保持一致：$l_{\text{occ}} = \|s_{\text{march}} - s\|_1$。
- **$l_{\text{stable}}$**：这是稳定化损失，用于防止 SDF 的零水平集在训练的前 1000 步中过度扩张或收缩。关于这个损失的更多细节，请参考 NeRO [Liu et al. 2023]。

然而，我们观察到，上述版本在几何细节的重建上存在次优问题（请参考第 5.5 节，无 $l_{\text{ilc}}$ 的消融实验）。这是由于引入了折射预测器 $g_r$。$g_r$ 倾向于过拟合反射分量，导致实际的反射预测器 $g_{\text{far}}$ 产生不准确的光照。由于 $g_r$ 很难约束，我们选择对 $g_{\text{far}}$ 添加正则化。因为最终的渲染颜色是折射和反射的总和，即使这种正则化没有直接应用于 $g_r$，它也是有效的。我们将其称为入射光一致性损失 $l_{\text{ilc}}$，它鼓励入射光预测 $g_{\text{far}}$ 与背景 NeRF 保持一致：

$$
l_{\text{ilc}} = \|g_{\text{far}}(\text{IDE}(\omega, 0)) - \sum_{i} w_{\text{bkgr}}^i c_{\text{bkgr}}^i\|_2 \quad (9)
$$

其中，$w_{\text{bkgr}}^i$ 和 $c_{\text{bkgr}}^i$ 是背景 NeRF $g_{\text{bkgr}}$ 沿射线计算的权重和颜色。我们在图 4 中展示了 $l_{\text{ilc}}$ 的公式和目的。

我们在表面重建阶段的总损失函数如下：

$$
L = l_{\text{render}} + I(\text{step} < 1000) l_{\text{stable}} + \sum_{k} \lambda_k l_k \quad (k \in \{\text{occ}, \text{eikonal}, \text{ilc}\}) \quad (10)
$$

其中，$I$ 是指示函数，$\text{step}$ 是训练步数，$\lambda_{\text{occ}}$、$\lambda_{\text{eikonal}}$ 和 $\lambda_{\text{ilc}}$ 是超参数，用于控制相应损失的乘数。


## 4 第二阶段：光线追踪迭代重建

在本节中，我们描述了光线追踪迭代重建方法。该策略能够使 NU-NeRF 重建外层透明表面内部的表面。从现在开始，我们将外层透明表面称为“界面”。我们首先讨论界面厚度为零的理想情况（第 4.1 节），然后将其扩展到非零厚度界面的情况（第 4.2 节）。最后，我们将第 3 节中描述的界面光线追踪和界面重建结合起来，形成一个完整的迭代策略（第 4.3 节）。在图 5 中，我们展示了零厚度和非零厚度界面的公式化方法。


### 4.1 零厚度界面  
在由固体透明材料（例如玻璃）制成的物体中，光线穿过界面时会发生反射和折射，入射能量的分布遵循菲涅尔方程（见图5(a)）。在这种情况下，光线只与界面发生一次相互作用。然而，在现实生活中，光线通常会经历两次相互作用，例如在透明容器的表面。我们首先描述一个简单的情况：界面非常薄。因此，光线折射进入界面后会立即射出。由于在这个过程中发生了两次连续的相互作用，菲涅尔项需要应用两次。由于材料非常薄，可以认为两次相互作用发生在同一位置，并且这两点的表面法线相同（见图5(b)）。然后，我们用两个独立的折射率（IoRs）$\eta_l$和$\eta_r$来描述这种类型的界面。$\eta_l$是界面材料的折射率，用于计算镜面反射颜色；$\eta_r$是内部物质材料的折射率，用于计算折射方向。例如，对于一个没有水的塑料瓶，$\eta_l = 1.5$，$\eta_r = 1.0$。作为一种特殊情况，具有单次相互作用的固体物体可以通过使用两个相同的折射率来简化实现。


### 4.2 非零厚度界面  
从零厚度界面扩展到非零厚度界面是自然的。我们额外引入了一个参数 $h$ 来模拟界面的厚度。由于厚度不能被忽略，光线的入射位置和出射位置不再相同，且这两点的法线也不同。为了准确捕捉这种效应，我们使用一个球体来模拟入射点的局部区域，球体的半径是通过入射点的高斯曲率 $K$ 计算得到的，该曲率可以通过数值方法在网格上计算 [Meyer et al. 2002]。半径通过 $r = \frac{1}{\sqrt{K}}$ 计算，假设两个主曲率 $\kappa_1$ 和 $\kappa_2$ 是相同的（见图 5(c)）。然而，对于非零厚度界面，还有一个问题需要考虑。当入射位置靠近几何形状的边缘时，光线会在界面内部反复发生全内反射。在这种情况下，光线不会进入界面的内部。为了应对这种情况，我们使用第一阶段（第 3 节）获得的几何形状渲染一个掩模，并对掩模应用腐蚀滤波器，以消除靠近几何形状边缘的样本（见图 5(d)）。核大小 $e_s$ 被视为一个可调节的超参数。

### 4.3 “洋葱”式迭代策略  
我们现在将界面重建与光线追踪重建结合起来。整个流程类似于“剥洋葱”，对最外层和内层表面重复相同的步骤：  
(1) 给定输入图像及其对应物体的姿态，应用界面重建（第3节）。在这个步骤中，重建了最外层的几何形状（可以是透明的或不透明的），同时学习了几何形状和背景NeRF的材料属性。  
(2) 将第一步的几何形状固定，并将其转换为一个界面，每个表面点上定义了两个折射率（IoRs）和一个可选的厚度（第4.1节、第4.2节）。光线被追踪并折射进入界面。在界面内部执行另一次界面重建过程以获得内层几何形状。第一阶段的所有网络（除了SDF网络）直接加载，并以较低的学习率与第二阶段的网络联合学习。这是为了通过第二阶段的精确光线追踪对第一阶段的网络进行细化。在第二次界面重建过程中，由于感兴趣的区域完全固定，因此移除了外层的NeRF和lilc。  
从理论上讲，(2)可以重复进行，以处理具有两层以上几何形状的物体。然而，在现实生活中，具有多个嵌套透明界面的几何形状很少见。考虑到流程的简洁性，本文仅考虑两层几何结构。


## 5 结果与评估

### 5.1 实验设置

**数据集和评估指标**  
我们在两种类型的数据集上评估了我们的方法和基线方法：

1. **合成数据集**  
   我们从公共数据集中收集了三种类型的物体：
   - **固体物体**：与之前工作中评估的物体类似，包含 Pig 和 Monkey 数据集。
   - **透明+透明物体**：外表面和内表面均为透明，包含 PlasticWater 和 GlassWater 数据集。
   - **透明+不透明物体**：内表面为不透明，包含 Spherepot 数据集。
   - **复杂组合物体**：内表面包含不透明和透明表面，包含 GlassIce 数据集。  
   每个数据集包含 250 张图像。对于需要掩码的基线方法，我们同时渲染了真实物体掩码和图像。

2. **真实数据集**  
   - 我们从 Bemana et al. [2022] 中选取了三个数据集：Ball、Glass 和 WineGlass。
   - 从互联网上收集了两个数据集：Lamp 和 PlasticBottle。这些数据集不包含真实形状。
   - 我们自己额外捕获了三个数据集：BallStatue、RealBottle 和 RealBottle2。输入图像是从手机拍摄的 1 分钟视频片段中提取的。需要注意的是，大约 10% 的图像存在各种伪影，如失焦和逆光（请参见图 6 的示例）。为了获得真实形状，我们使用 AESUB 蓝色扫描喷雾对物体进行喷涂，并使用 Revopoint POP 3 扫描仪进行扫描。定量实验仅在我们自己捕获的数据集上进行。基线方法所需的物体掩码是使用现成的方法 [Contributors 2020] 标注的，并手动调整以提高准确性。

**定量评估**  
为了定量评估重建的几何结构，我们比较了重建几何与真实网格之间的**Chamfer 距离（CD）** [Barrow et al. 1977] 和**Earth Mover’s 距离（EMD）** [Rubner et al. 2000]。这两种距离都是通过在网格上随机采样 50,000 个点来计算的。对于嵌套物体，外表面和内表面的 CD 均进行了计算。对于无法重建内表面的基线方法或消融版本，仅计算外表面的距离。消融研究仅在合成数据集上进行。

**基线方法**  
由于我们的方法专注于在无控制的捕获环境中重建嵌套透明物体的几何结构，因此没有与我们设置完全相同的状态最先进的方法（有关不同方法的设置，请参考补充材料）。最近的方法需要专用背景 [Li et al. 2023a; Lyu et al. 2020; Xu et al. 2022] 或特定环境 [Gao et al. 2023]。另一方面，Li et al. [2020] 和 NeMTO [Wang et al. 2023] 仅需要物体掩码和环境图，这些都可以仅通过输入图像进行估计，无需重新捕获图像，这与我们的设置最为接近。因此，我们将 Li et al. [2020] 和 NeMTO [Wang et al. 2023] 作为定性和定量比较的基线方法。最近的 Gao et al. [2023] 和 ReNeuS [Tong et al. 2023] 也探索了透明物体重建，但对捕获环境的要求更多，包括足够大的不透明平面、真实外表面和均匀光照。因此，我们选择了一些满足这些方法捕获要求的案例进行定性比较。有关不同基线的详细设置，请参考补充材料。

## 5.2 合成数据集上的结果

我们的 NU-NeRF、NEMTO [Wang et al. 2023] 和 Li et al. [2020] 在合成数据集上的定性和定量重建结果分别如图 7 和表 1 所示。在 Pig 和 Monkey 数据集的结果表明，与需要额外输入的现有方法相比，我们的方法能够重建出具有更多几何细节的固体透明形状，尽管某些锐利区域（如 Pig 和 Monkey 数据集的眼睛部分）被“平滑”了。这是因为这些区域出现了强烈的全内反射。这种现象在其他最先进（SOTA）方法 [Li et al. 2020; Wang et al. 2023] 中也可以观察到。

对于更复杂的嵌套表面情况（如 SpherePot、PlasticWater 和 GlassWater），我们的方法不仅能够重建出详细的外表面几何结构（例如 PlasticWater 案例中的褶皱），还能够重建内表面。相比之下，NEMTO [Wang et al. 2023] 和 Li et al. [2020] 甚至无法恢复外表面的详细几何结构，例如在 PlasticWater 案例中。这是因为 NEMTO 的光线弯曲网络无法泛化到这些情况，并预测了错误的光线路径，而 Li et al. 的法线和点云预测网络仅估计外表面的法线和点云。GlassIce 案例更具挑战性，其中内物体包含不透明的吸管和透明的冰，吸管在场景中既有内部分支也有外部分支。我们的方法能够忠实地重建所有内表面几何结构，并且内吸管和外吸管能够对齐。图 1 中的重新渲染结果表明重建结果是准确的。这种案例显然超出了基线方法 [Li et al. 2020; Wang et al. 2023] 的重建能力，因为它们只关注外表面重建，并依赖于不准确的光线路径、法线和点云估计。因此，它们的外表面重建结果往往比我们的更平滑，并且遗漏了细节。

## 5.3 真实数据集上的结果

我们的 NU-NeRF、NEMTO [Wang et al. 2023] 和 Li et al. [2020] 在真实捕获数据集上的重建结果分别如图 8 和图 9 所示。图 8 包含五个没有真实几何结构的现实场景，其中三个（Ball、Glass 和 Plastic）包含内部没有几何结构的物体，另外两个包含内部有物体的透明外表面。图 9 包含三个使用扫描仪捕获的场景，其中可以获取内外表面的真实几何结构，以便进行定性和定量比较。可以看出，我们的方法能够在图 8 中复杂的现实捕获场景中无需物体掩码重建外表面几何结构。尽管与合成数据的结果相比，由于每场景的图像数量较少（大约 100 张，远少于合成场景的 250 张）以及相机姿态不够准确，重建结果的某些区域受到影响，例如 Glass 案例的底部区域。在 WineGlass 案例中，尽管外表面几何结构存在不准确之处，但我们的 NU-NeRF 仍然能够重建内表面。由于第二阶段使用的光线追踪技术，内外部分的铅笔形状能够对齐。在 Lamp 案例中，场景中包含一个发出强光的灯泡，我们的方法能够稳健地重建内外表面几何结构。然而，两种基线方法都无法重建内表面，并且在外表面重建方面表现更差。

在图 9 中，BallStatue 案例包含透明外表面和不透明内表面，外表面还存在反射。我们的方法能够很好地处理这些复杂的视觉效果，而不会丢失过多的几何细节，这从内外表面的质量可以看出。两种基线方法 [Li et al. 2020; Wang et al. 2023] 在固体物体上可以产生合理的结果，但在存在嵌套表面以及透明和不透明材料时，无法产生可靠的结果。当背景不是“无限远”或输入光照估计不准确时，NEMTO [Wang et al. 2023] 会陷入困境。Li et al. [2020] 的方法倾向于“过度平滑”几何结构，因为其包含一个几何平滑步骤。我们的方法与基线方法之间的定量比较结果如表 2 所示。更好的几何重建质量也反映在这些指标上，我们的方法位居榜首。

## 5.4 与需要受控捕获环境的基线方法的比较

在本节中，我们将提出的 NU-NeRF 流程与其他需要受控捕获环境的透明物体重建方法进行了比较。具体来说，我们选择了两个基线方法：Gao et al. [2023] 和 ReNeuS [Tong et al. 2023]。Gao et al. [2023] 的目标是在没有额外输入的情况下重建透明物体，但需要物体放置在一个足够大的不透明平面上，且无法支持嵌套物体。另一方面，ReNeuS [Tong et al. 2023] 仅专注于重建透明物体内部的不透明物体，这些物体的外表面几何结构已知，并且在均匀光照下捕获。

**Gao et al. [2023]**  
我们在两个不同的场景中将我们的方法与 Gao et al. [2023] 进行了比较：第一个是 PigPlane，它简单地在 Pig 数据集中添加了 Gao et al. [2023] 所需的平面；第二个是来自 Bemana et al. [2022] 的 Ball 数据集，该数据集将物体放置在一个相对较小的平面上。由于在我们进行实验时，他们的方法的代码尚未公开发布，因此我们选择基于 NeuS [Wang et al. 2021] 的代码自行实现该方法。如图 10 的第一行所示，当平面足够大时，Gao et al. [2023] 可以重建出合理的几何结构，但由于其轮廓估计不够准确，可能会遗漏几何细节（如 Pig 的脚）。当平面不够大时，如第二行所示，由于平面参数估计不准确，导致结果更差，因为渲染颜色是通过弯曲光线与估计平面的交点来确定的。

**ReNeuS [Tong et al. 2023]**  
我们在两个不同的场景中将我们的方法与 ReNeuS 进行了比较：第一个是 GlassIce，第二个是 BallStatue。在运行该方法时，我们提供了外表面几何结构的真实形状。同样，由于代码不可用，我们选择自行实现该方法。如图 11 所示，ReNeuS 无法处理更复杂的视觉效果，例如透明的内表面几何结构和反射的外表面几何结构，这导致了错误的几何重建，例如冰上的塌陷表面和雕像顶部。相比之下，我们对更复杂的光照交互（包括反射和折射）进行了建模，从而实现了更准确的几何重建。
## 5.5 消融研究

NU-NeRF 包含两个阶段，每个阶段都有多种设计选择。为了测试这些设计的有效性，我们移除了完整流程中的一些组件，并将这些版本与完整版本进行比较。消融研究包括以下内容：

- **不使用 $g_r$**：首先移除 $g_r$ 网络。$g_r$ 的作用是建模折射光，因此这一版本相当于 NeRO [Liu et al. 2023] 加上 $l_{\text{ilc}}$ 损失。
- **仅使用 $g_r$**：$g_r$ 本身是一个 NeRF 颜色网络。为了验证我们的方法不仅仅依赖于 $g_r$ 来学习反射和折射颜色，我们移除了反射部分 $g_l$，仅使用 $g_r$ 进行消融实验。
- **不使用 $l_{\text{ilc}}$**：$l_{\text{ilc}}$ 被引入到我们的流程中，以增加学习到的光照 $g_{\text{inf}}$ 与外部 NeRF 的一致性。
- **不使用两个折射率 $\eta_r$ 和 $\eta_l$（即固体假设）**：我们使用两个折射率（IoR）来建模界面和内部物质，以处理嵌套表面。我们移除了双折射率公式，改用具有空间变化折射率的单层界面来建模输入场景。这一版本在 PlasticWater 和 GlassWater 案例中进行了评估。
- **不使用非零厚度公式**：在这种消融中，我们移除了非零厚度公式，仅应用零厚度界面。这一版本在 GlassWater 案例中进行了评估。

消融研究的结果分别如图 12、图 13、表 3 和表 4 所示。从图 12 可以看出，如果没有 $g_r$，该方法无法产生有意义的结果，因为折射颜色未被建模。仅使用 $g_r$ 产生的结果（如图 12 所示）也较差，因为忽略了反射部分。此外，如果未应用 $l_{\text{ilc}}$，如图 12 所示，几何细节将会丢失。

此外，如图 13 所示，如果没有引入双折射率公式，网络将学习界面和内部材料折射率的“平均”版本，内表面 SDF 将产生多余的几何结构以补偿不准确的折射。最后，如果没有使用非零厚度公式，在 GlassWater 案例的顶部区域将出现多余的几何结构。这是因为界面的厚度导致光线在此区域发生弯曲。如果使用零厚度假设，网络将无法预测这种弯曲和畸变，从而导致内表面 SDF 的补偿。

## 6 结论

在本文中，我们提出了 NU-NeRF，用于在无控制的捕获环境中对嵌套透明物体进行几何重建。该方法克服了当前透明物体重建方法的局限性，包括仅适用于固体物体以及对输入和捕获环境的额外要求。为了消除对任何捕获环境和额外输入的需求，我们引入了神经隐式表示，并使用符号距离场（SDF）来实现表面重建。我们使用基于物理的双向散射分布函数（BSDF）定义的 Cook-Torrance 反射和透射来建模界面，并引入了分裂求和近似以实现高效的渲染。为了建模折射，我们引入了一个简单而有效的单层 MLP（多层感知机）来预测折射颜色。此外，我们还引入了一种新颖的入射光一致性损失，以提高外表面重建的保真度。此外，我们的方法通过使用光线追踪迭代重建实现了嵌套物体的重建。我们调整了外表面和内部物质的可学习折射率（IoR），并引入了基于光线追踪的渲染，显式建模光线路径，以实现内表面的几何重建。

我们在合成数据集和真实捕获数据集上评估了我们的方法，结果表明，我们的方法优于当前针对透明物体重建问题的方法。然而，我们的方法仍然存在以下局限性：首先，我们的方法尚未建模复杂的光学效应，如全内反射。其次，尽管从理论上讲是可行的，但我们的方法目前无法处理超过两层的表面。对于未来的研究方向，我们希望在第一阶段和第二阶段都考虑实际的光传输，以提高重建质量，并将范围扩展到具有三层或更多层的更复杂几何结构。

## 致谢

本研究得到了中国国家自然科学基金（No.62322210）、中科院计算技术研究所创新基金（No.E461020）、北京市自然科学基金杰出青年学者项目（No.JQ21013）以及北京市科学技术委员会（No.Z231100005923031）的支持。Ling-Qi Yan 还得到了来自 Adobe、Intel、Lintex、Meta 和 XVerse 的资助支持。我们还要感谢 KIRI Innovations 在数据捕获方面的支持。



NU-NeRF: Neural Reconstruction of Nested Transparent Objects with Uncontrolled Capture Environment  

## Supplementary Material

**作者信息**：  
Jia-Mu Sun, Institute of Computing Technology, CAS and KIRI Innovations, China  
Tong Wu, Institute of Computing Technology, CAS and University of Chinese Academy of Sciences, China  
Ling-Qi Yan, Department of Computer Science, University of California, Santa Barbara, United States  
Lin Gao*, Institute of Computing Technology, CAS and University of Chinese Academy of Sciences, China  

**ACM 引用格式**：  
Jia-Mu Sun, Tong Wu, Ling-Qi Yan, and Lin Gao. 2024. NU-NeRF: Neural Reconstruction of Nested Transparent Objects with Uncontrolled Capture Environment: Supplementary Material. ACM Trans. Graph. 43, 6, Article 262 (December 2024), 9 pages. [https://doi.org/10.1145/3687757](https://doi.org/10.1145/3687757)



## 1 NU-NeRF 与以往透明物体重建工作的差异

在主论文中已经提到，NU-NeRF 的任务与以往的工作有所不同。我们在表 1 中展示了我们提出的 NU-NeRF 与以往工作的详细对比。可以看出，我们的方法能够在更少的输入条件下重建更多类型的场景。

## 2 第一阶段的中间结果

我们的方法的第一阶段重建不仅可以进行界面重建，还可以作为过程的“副产品”产生材质分解。我们在图 1 中展示了一些合成场景的分解结果。

## 3 第二阶段网格的后处理

对于某些场景，第二阶段重建的网格并不“干净”：可能存在一些多余的几何结构。我们将多余的几何结构分为两类：由 SDF 引起的和补偿性的。第一类是提取第二阶段几何结构时的伪影。在提取时，我们手动将第一阶段几何结构外部的任何点的 SDF 设置为 +1。因此，如果内 SDF < 0，则会在第一阶段几何结构的表面上出现多余的几何结构。第二类是由第一阶段几何结构的不准确引起的。在不准确的区域，内几何结构被学习用来补偿不准确的折射颜色。幸运的是，这两种多余的几何结构通常都离第一阶段几何结构非常近。

为了移除多余的几何结构，我们进行了一种非常简单的后处理过程：简单地移除那些离第一阶段几何结构过近的顶点及其连接的面（即顶点到第一阶段几何结构表面的距离 < $\epsilon_p$。在实验中，$\epsilon_p$ 被设置为 0.01。对于非零厚度界面，距离被设置为 $h + \epsilon_p$，这就是主论文图 5 中显示的“收缩”水面的原因）。这个过程如图 2 所示。请注意，这两种多余的几何结构与主论文图 6 中显示的结果不同，那些几何结构并不靠近第一阶段表面，而是由不准确的表面公式引起的。主论文图 6 中的所有几何结构都是后处理的结果。

## 4 在合成数据上使用较少图像的评估

我们在 Pig 和 Monkey 数据集中随机选取了 65 张图像进行实验（与原始数据集中的 250 张图像相比），并在图 3 中展示了重建几何结构的差异。我们观察到，在几何结构较为简单的 Pig 案例中，图像数量不足的影响较小。对于像 Monkey 这样复杂的物体，在光线多次折射的区域（例如猴子的腿部）可能会出现一些伪影。



## 5 训练和数据集细节

在训练第一阶段网络时，我们将主论文公式 (10) 中的损失乘数设置如下：$\lambda_{\text{occ}} = 1.0$，$\lambda_{\text{eikonal}} = 0.1$，$\lambda_{\text{ilc}} = 0.5$。我们使用 ADAM 优化器，学习率为 $5 \times 10^{-4}$，并设置 5000 步的预热期，优化网络 3 × 10^5 步。训练过程在单个 NVIDIA RTX 4090 GPU 上需要 6-8 小时（具体时间取决于输入图像的大小）。

在训练第二阶段网络时，移除了 $l_{\text{ilc}}$，并将加载的第一阶段网络的学习率设置为 $5 \times 10^{-5}$。训练持续 1 × 10^5 步。训练过程在单个 NVIDIA RTX 4090 GPU 上需要 1-2 小时。

我们在图 4 中展示了用于重建的 MLP 的层参数和结构细节。需要注意的是，主论文指出折射率 $\eta$ 可以由 MLP 预测，并用于计算镜面反射颜色，但在我们的实际实现中，由于数值稳定性问题，我们使用了 0.04 作为固定的镜面反射颜色。实验表明，这种近似对重建质量没有影响。

Pig 和 Monkey 的 3D 模型来自 Li et al. [2020] 的数据，其余三个模型来自 Blendswap.com，并由我们进行了修改。这些数据集是使用 Blender [Community 2023] 中的 Cycles 渲染引擎渲染的，背景来自 Hdrmaps.com。



## 6 场景中心和半径的评估

由于我们的方法基于 NeuS [Wang et al. 2021]，因此需要场景中心和半径来进行归一化。我们为用户提供了两种解决方案：

1. **用户指定子集**：用户可以从相机姿态估计系统（如 COLMAP [Schönberger and Frahm 2016; Schönberger et al. 2016]）提供的点云中指定一个子集，中心和半径直接从该子集计算得出（中心是其包围盒的中心，半径是从任意点到中心的最大距离）。这基于 NeRO [Liu et al. 2023] 的公开代码，其手册使用 CloudCompare [Contributors 2024] 手动裁剪子集。

2. **自动评估中心和半径**：这基于 instant-nsr-pl [Guo 2022] 的公开代码。自动评估过程如下：
   - **球体中心的近似**：如果相机均匀分布在物体周围的球体上，可以简单地使用所有相机位置的平均值来近似球体中心；如果相机分布在半球体或其他形状上，则可以将其视为最小二乘问题，高效计算所有相机的“Lookat”方向的近似交点。
   - **球体半径的设置**：可以将半径设置为任意相机到中心的最小距离的比例（根据我们的实验，距离的 0.7 倍应该可以工作）。

如果读者参考图 5 的示例（BallStatue 数据集的评估过程），将更容易理解这一过程。

## 7 厚度重建细节

在主论文中，我们引入了非零厚度重建公式。由于高斯曲率是从网格计算得到的，而厚度和折射率是由网络预测的，因此重建的厚度可能并不准确。准确重建厚度超出了本文的范围，因此在某些区域厚度可能与真实值存在差异（这并不会严重影响重建结果，因为折射率可以补偿厚度，且光线路径对厚度并不敏感，请参阅图 6 查看渲染结果）。只要外表面和内表面能够被准确重建，我们就认为重建是成功的。在图 6 中，我们展示了非厚度光线追踪流程在测试场景上的渲染结果，并将其与真实输入进行了对比。从图中可以看出，渲染结果正确地“弯曲”了背景，就像输入图像一样，尤其是在物体的边缘部分。这表明我们提出的公式在物理上是正确的。



## 8 更多重建结果

我们还在两个真实捕获的数据集上进行了实验，这些数据集也是使用移动设备在日常环境中捕获的。这两个数据集分别是 Tallbottle 和 Boxcup，其中后者是一个“透明外表面 + 透明内表面”的场景。重建结果如图 7 所示。由于这仅是为了展示所提方法的重建示例，因此我们并未将这些结果与其他方法进行比较。



## 9 失败案例

我们主要展示了两种类型的失败案例：

1. **在处理存在普遍且一致的全反射效应的场景时，我们的方法可能会产生空心表面**。这在图 8 中有描述。
2. **如果第一阶段的表面重建不完美，那么在第二阶段无法进一步优化，这可能会导致内表面重建失败，尤其是当第一阶段的网格不正确时**。这在图 9 中有描述。



# 部分论文翻译及解释

## 翻译

4.1 零厚度界面  
在由固体透明材料（例如玻璃）制成的物体中，光线穿过界面时会发生反射和折射，入射能量的分布遵循菲涅尔方程（见图5(a)）。在这种情况下，光线只与界面发生一次相互作用。然而，在现实生活中，光线通常会经历两次相互作用，例如在透明容器的表面。我们首先描述一个简单的情况：界面非常薄。因此，光线折射进入界面后会立即射出。由于在这个过程中发生了两次连续的相互作用，菲涅尔项需要应用两次。由于材料非常薄，可以认为两次相互作用发生在同一位置，并且这两点的表面法线相同（见图5(b)）。然后，我们用两个独立的折射率（IoRs）$\eta_l$和$\eta_r$来描述这种类型的界面。$\eta_l$是界面材料的折射率，用于计算镜面反射颜色；$\eta_r$是内部物质材料的折射率，用于计算折射方向。例如，对于一个没有水的塑料瓶，$\eta_l = 1.5$，$\eta_r = 1.0$。作为一种特殊情况，具有单次相互作用的固体物体可以通过使用两个相同的折射率来简化实现。

## 解释

### 1. **零厚度界面的背景**
- 在透明材料（如玻璃）中，光线穿过界面时会发生反射和折射。这种现象可以用菲涅尔方程来描述，即入射能量在反射和折射之间分配（见图5(a)）。
- 在理想情况下，光线与界面只发生一次相互作用。但在实际场景中，例如透明容器的表面，光线可能会经历两次相互作用：一次是进入界面，一次是离开界面。

### 2. **薄界面的处理方法**
- 当界面非常薄时，光线进入界面后会立即射出。这种情况下，虽然光线经历了两次相互作用（进入和离开），但可以近似认为两次相互作用发生在同一位置，且这两点的法线相同（见图5(b)）。
- 因此，菲涅尔项需要应用两次，以分别处理进入和离开界面的光线。

### 3. **折射率的定义**
- 为了描述这种薄界面，作者引入了两个独立的折射率（Index of Refraction, IoR）：
  - $\eta_l$：界面材料的折射率，用于计算镜面反射颜色（specular color）。
  - $\eta_r$：内部物质的折射率，用于计算折射方向。
- 例如，对于一个空的塑料瓶，界面材料的折射率 $\eta_l = 1.5$，而内部空气的折射率 $\eta_r = 1.0$。

### 4. **特殊情况的简化**
- 对于只有一次相互作用的固体物体（例如不透明物体），可以使用两个相同的折射率来简化实现。这是因为在这种情况下，光线只与界面发生一次相互作用，因此不需要区分进入和离开的折射率。

### 5. **总结**
- 这段内容主要讨论了如何在渲染中处理零厚度界面的问题。通过引入两个独立的折射率，可以更准确地模拟光线在薄界面中的行为，同时简化了实现过程。这种处理方法特别适用于透明容器等场景，能够更好地模拟光线的反射和折射效果。


## 翻译

4.2 非零厚度界面  
从零厚度界面扩展到非零厚度界面是自然的。我们额外引入了一个参数 $h$ 来模拟界面的厚度。由于厚度不能被忽略，光线的入射位置和出射位置不再相同，且这两点的法线也不同。为了准确捕捉这种效应，我们使用一个球体来模拟入射点的局部区域，球体的半径是通过入射点的高斯曲率 $K$ 计算得到的，该曲率可以通过数值方法在网格上计算 [Meyer et al. 2002]。半径通过 $r = \frac{1}{\sqrt{K}}$ 计算，假设两个主曲率 $\kappa_1$ 和 $\kappa_2$ 是相同的（见图 5(c)）。然而，对于非零厚度界面，还有一个问题需要考虑。当入射位置靠近几何形状的边缘时，光线会在界面内部反复发生全内反射。在这种情况下，光线不会进入界面的内部。为了应对这种情况，我们使用第一阶段（第 3 节）获得的几何形状渲染一个掩模，并对掩模应用腐蚀滤波器，以消除靠近几何形状边缘的样本（见图 5(d)）。核大小 $e_s$ 被视为一个可调节的超参数。

## 解释

### 1. **非零厚度界面的引入**
- 在光学和几何建模中，界面的厚度是一个重要的因素。当界面厚度为零时，光线的入射点和出射点可以认为是同一个点，法线也相同。然而，当界面有非零厚度时，光线的入射点和出射点会分开，且这两点的法线也会不同。因此，需要引入参数 $h$ 来模拟这种厚度。

### 2. **局部区域的建模**
- 为了准确模拟光线在界面中的行为，作者使用一个球体来近似入射点的局部区域。球体的半径 $r$ 通过入射点的高斯曲率 $K$ 计算，公式为：
  
  $$
  r = \frac{1}{\sqrt{K}}
  $$

- 高斯曲率 $K$ 是一个几何量，表示表面在某一点的弯曲程度。它可以通过数值方法在网格上计算，例如使用 Meyer 等人 [2002] 提出的方法。
- 假设两个主曲率 $\kappa_1$ 和 $\kappa_2$ 相等，这简化了计算过程。

### 3. **边缘效应的处理**
- 当光线入射在界面的边缘附近时，可能会发生多次全内反射，导致光线无法进入界面内部。这种现象在实际应用中需要特别处理。
- 作者通过以下方法解决这一问题：
  1. 使用第一阶段生成的几何形状渲染一个掩模（mask）。
  2. 对模掩应用腐蚀滤波器（erosion filter），以去除靠近几何形状边缘的样本。
- 腐蚀滤波器的核大小 $e_s$ 是一个可调节的超参数，可以根据具体需求进行调整。

### 4. **图示说明**
- 文中提到的图 5(c) 和图 5(d) 应该展示了球体半径的计算方法和掩模处理的效果。这些图示有助于更直观地理解上述概念。

### 5. **总结**
- 这段内容主要讨论了如何在几何建模中处理非零厚度界面的问题。通过引入参数 $h$ 和使用球体局部建模，可以更准确地模拟光线在界面中的行为。同时，通过腐蚀滤波器处理边缘效应，避免了光线在边缘附近发生多次全内反射的问题。


## 翻译

4.3 “洋葱”式迭代策略  
我们现在将界面重建与光线追踪重建结合起来。整个流程类似于“剥洋葱”，对最外层和内层表面重复相同的步骤：  
(1) 给定输入图像及其对应物体的姿态，应用界面重建（第3节）。在这个步骤中，重建了最外层的几何形状（可以是透明的或不透明的），同时学习了几何形状和背景NeRF的材料属性。  
(2) 将第一步的几何形状固定，并将其转换为一个界面，每个表面点上定义了两个折射率（IoRs）和一个可选的厚度（第4.1节、第4.2节）。光线被追踪并折射进入界面。在界面内部执行另一次界面重建过程以获得内层几何形状。第一阶段的所有网络（除了SDF网络）直接加载，并以较低的学习率与第二阶段的网络联合学习。这是为了通过第二阶段的精确光线追踪对第一阶段的网络进行细化。在第二次界面重建过程中，由于感兴趣的区域完全固定，因此移除了外层的NeRF和lilc。  
从理论上讲，(2)可以重复进行，以处理具有两层以上几何形状的物体。然而，在现实生活中，具有多个嵌套透明界面的几何形状很少见。考虑到流程的简洁性，本文仅考虑两层几何结构。


## 解释

### 1. **“洋葱”式迭代策略的背景**
- 本文提出了一种结合界面重建和光线追踪重建的方法，用于处理具有透明或不透明几何形状的物体。
- 这种策略的核心思想是通过迭代的方式，逐步从外层到内层重建物体的几何形状和材质属性。这种迭代过程类似于“剥洋葱”，逐层处理物体的结构。

### 2. **步骤1：界面重建**
- **输入**：输入图像及其对应的物体姿态。
- **目标**：重建最外层的几何形状（可以是透明或不透明的），并学习几何形状和背景NeRF的材质属性。
- 这一步主要利用第3节中描述的界面重建方法，重点在于获取物体的外层几何形状和相关材质信息。

### 3. **步骤2：光线追踪与内层重建**
- **固定外层几何形状**：将第一步重建的几何形状固定，并将其转换为一个界面。每个表面点上定义了两个折射率（IoRs）和一个可选的厚度（具体方法见第4.1节和第4.2节）。
- **光线追踪**：光线被追踪并折射进入界面。
- **内层重建**：在界面内部执行另一次界面重建过程，以获得内层几何形状。
- **网络联合学习**：第一阶段的所有网络（除了SDF网络）被直接加载，并以较低的学习率与第二阶段的网络联合学习。这种联合学习的目的是利用第二阶段的精确光线追踪对第一阶段的网络进行细化。
- **移除外层NeRF和lilc**：在第二次界面重建过程中，由于感兴趣的区域完全固定，因此移除了外层的NeRF和lilc（可能是某种网络组件）。

### 4. **多层几何结构的处理**
- 从理论上讲，步骤2可以重复进行，以处理具有两层以上几何结构的物体。
- 然而，在现实生活中，具有多个嵌套透明界面的几何结构非常罕见。因此，为了简化流程，本文仅考虑两层几何结构。

### 5. **总结**
- 这种“洋葱”式迭代策略的核心在于通过逐步重建外层和内层几何结构，结合界面重建和光线追踪重建的优势，以更精确地处理具有透明或不透明几何形状的物体。
- 通过固定外层几何形状并逐步细化内层结构，该方法能够有效地处理复杂的几何和材质属性，同时保持流程的简洁性。

# 部分论文代码解释【Sonnet-3.5】

## Stage2Renderer.render代码讲解

- [class Stage2Renderer.render coding link](https://github.com/78ij/NU-NeRF/blob/1c598495a92d7a0cc99efbbeb88629d617b67a3e/network/renderer.py#L1610)

这段代码实现了一个光线追踪渲染器,主要用于模拟透明物体的光线传播。让我为您解析主要功能:

## 主要功能

`ray_trace` 函数的主要功能:
```python
def ray_trace(self,rays_o,rays_d,mask):
    # rays_o: 光线起点
    # rays_d: 光线方向
    # mask: 遮罩
```

主要实现了以下功能:

1. 光线追踪循环:
- 最多追踪3次光线反射/折射
- 每次追踪都会:
  - 计算光线与物体的交点
  - 计算表面法线
  - 根据折射率计算折射方向
  - 处理全反射(TIR)情况

2. 折射计算:
```python
# 计算入射角余弦
cos_thetai = torch.sum(normal * -next_dir,dim=-1,keepdim=True)
# 计算折射角正弦平方
sin_thetat_2 = sin_thetai_2 * ior_ratio * ior_ratio
```

3. 采样点生成:
- 在光线路径上生成采样点用于体积渲染
- 对内部和外部区域使用不同的采样策略

4. `render_core` 函数实现了渲染核心功能:
- 计算每个采样点的颜色和不透明度
- 使用体积渲染积分得到最终颜色
- 处理内部和外部区域的渲染
- 计算法线、高光等渲染特征


主要创新点:
- 结合了显式表面和隐式表面的渲染
- 支持多次折射和反射
- 考虑了材质的折射率变化
- 实现了基于物理的真实感渲染

这是一个复杂的渲染系统,用于生成透明物体的真实感图像。它结合了传统光线追踪和神经渲染的技术。

需要注意的是,代码中使用了一些深度学习组件(如 sdf_network、color_network 等),这表明这是一个基于神经网络的渲染器。

### 曲率作用

在这个渲染系统中，曲率(curvature)的计算主要有以下几个用途：

1. 表面特征表示：
```python
# 曲率计算用于表征表面的局部几何特征
# mean curvature = (k1 + k2)/2，其中k1和k2是主曲率
mean_curvature = torch.sum(curvature, dim=-1, keepdim=True) * 0.5
```

主要作用：
- 帮助描述物体表面的弯曲程度
- 用于区分凸面、凹面和平面区域
- 影响材质的渲染效果

2. 渲染效果增强：
- 曲率信息可以用来调整：
  - 表面的反射特性
  - 高光的分布
  - 边缘的渲染效果
- 特别是在透明物体中，曲率较大的区域往往会产生更明显的光学效果

3. 物理准确性：
```python
# 曲率影响光线的传播
# 在高曲率区域，光线会发生更强的折射和反射
if use_curvature:
    specular = specular * (1.0 + mean_curvature)
```

4. 视觉提示：
- 曲率信息可以帮助观察者更好地理解：
  - 物体的3D形状
  - 表面的细节特征
  - 材质的质感

总的来说，曲率在这个渲染系统中扮演着重要角色，它不仅影响光线的传播行为，还能增强渲染的真实感。特别是对于透明物体，准确的曲率计算对于模拟真实的光学效果至关重要。

### 使用SDF MLP计算曲率（非Nu-NeRF的实现方式）


如果需要使用SDF MLP计算曲率，曲率是通过计算SDF（Signed Distance Function）的二阶导数来获得的。让我们看看具体实现：

```python
def get_curvature(self, x, sdf=None, gradients=None):
    if sdf is None:
        sdf = self.sdf_network.sdf(x)
    if gradients is None:
        gradients = self.gradient(x, sdf)
    
    # 计算二阶导数
    d2_x = torch.autograd.grad(gradients[..., 0].sum(), x, create_graph=True)[0][..., 0]
    d2_y = torch.autograd.grad(gradients[..., 1].sum(), x, create_graph=True)[0][..., 1]
    d2_z = torch.autograd.grad(gradients[..., 2].sum(), x, create_graph=True)[0][..., 2]
    
    # 计算混合偏导数
    d2_xy = torch.autograd.grad(gradients[..., 0].sum(), x, create_graph=True)[0][..., 1]
    d2_xz = torch.autograd.grad(gradients[..., 0].sum(), x, create_graph=True)[0][..., 2]
    d2_yz = torch.autograd.grad(gradients[..., 1].sum(), x, create_graph=True)[0][..., 2]
```

计算过程主要包括：

1. 获取一阶导数（梯度）：
- 首先通过 `gradient` 函数获取SDF关于空间坐标的一阶导数
- 这个梯度表示了表面法线方向

2. 计算二阶导数：
- 使用 `torch.autograd.grad` 计算Hessian矩阵的元素
- 包括：
  - 纯二阶导数：d2_x, d2_y, d2_z
  - 混合偏导数：d2_xy, d2_xz, d2_yz

3. 曲率计算：
```python
# 构建Hessian矩阵
hessian = torch.stack([
    torch.stack([d2_x, d2_xy, d2_xz], dim=-1),
    torch.stack([d2_xy, d2_y, d2_yz], dim=-1),
    torch.stack([d2_xz, d2_yz, d2_z], dim=-1)
], dim=-2)

# 计算主曲率
curvature = compute_curvature_from_hessian(hessian, gradients)
```

这种计算方法的优点：
- 精确：通过二阶导数可以准确捕捉表面的局部几何特征
- 可微分：支持梯度反向传播，适合深度学习框架
- 通用性：适用于任何隐式表面

需要注意的是：
1. 这种计算方式计算量较大，因为需要多次计算自动微分
2. 在实际应用中可能需要添加数值稳定性的处理
3. 曲率的计算依赖于SDF网络的质量

这种基于SDF的曲率计算方法在神经渲染中很常见，因为它能够准确地表达表面的几何特征，对于生成高质量的渲染结果很重要。

### Nu-NeRF中曲率计算

让我们看看这份代码中曲率的计算：

在这份代码中，曲率（gaussian_curvature）是通过 `Dintersect` 函数获得的：

```python:_posts/hi.py
# 对于外部光线
if is_outside:
    intersection_info, converged = self.scene.Dintersect(rays_for_intersection)
    converged = converged.bool().reshape(-1,1).detach()
    intersection = intersection_info.intersection_point
    gaussian_curvature = intersection_info.g_k  # 从intersection_info中获取高斯曲率
    normal = F.normalize(intersection_info.n, dim=-1)
```

具体来看：

1. 曲率是通过 `self.scene.Dintersect()` 函数计算得到的，作为 `intersection_info` 的一部分返回
2. 通过 `intersection_info.g_k` 获取高斯曲率值
3. 这个曲率值后续被用于：
   - 计算曲率半径：`curvature_radius = 1 / torch.sqrt(torch.clamp(torch.abs(gaussian_curvature),min=0.000001))`
   - 区分正负曲率：`curvature_positive = gaussian_curvature >= 0`

不过需要注意的是，实际的曲率计算实现是在 `self.scene.Dintersect()` 中完成的，但这部分代码没有在给出的代码片段中显示。要了解具体的计算方法，我们需要查看 `Dintersect` 函数的实现。

### 曲率计算的实现

- [class Scene coding link](https://github.com/78ij/NU-NeRF/blob/1c598495a92d7a0cc99efbbeb88629d617b67a3e/network/DiffRender.py#L318)

从Scene类的代码中可以看到，高斯曲率的计算是通过PyMesh库完成的：

```python
def init_VN(self):
    # ...
    self.pymesh_mesh.add_attribute("vertex_gaussian_curvature")
    # 获取高斯曲率并限制在[-10.0, 10.0]范围内
    self.gaussian_curvatures = torch.tensor(
        np.clip(
            self.pymesh_mesh.get_attribute("vertex_gaussian_curvature"),
            a_min=-10.0,
            a_max=10.0
        ),
        device='cuda:0'
    ).reshape(vertices.shape[0],1)
```

具体过程是：

1. 在初始化时，通过 `pymesh.meshio.load_mesh()` 加载网格
2. 调用 `add_attribute("vertex_gaussian_curvature")` 计算每个顶点的高斯曲率
3. 使用 `get_attribute()` 获取计算好的高斯曲率值
4. 将曲率值限制在 [-10.0, 10.0] 范围内
5. 转换为 torch.tensor 并存储在 GPU 上

当需要获取某个交点的曲率时，在 `Dintersect` 方法中：

```python
def Dintersect(self, ray: Ray):
    faces_ind, hitted = self.optix_intersect(ray)
    faces = self.faces[faces_ind[hitted]]
    triangles = self.vertices[faces].float()
    normals = self.normals[faces].float()
    curvatures = self.gaussian_curvatures[faces].float()  # 获取相关面的顶点曲率
    ray_hitted = ray.select(hitted)

    # 通过JIT_Dintersect计算交点的具体信息，包括插值后的曲率
    u, v, t, n, g_k = JIT_Dintersect(ray_hitted.origin, ray_hitted.direction, triangles, normals, curvatures)
```

这里的曲率计算实际上是由PyMesh库完成的，代码中只是在使用计算好的结果。PyMesh使用离散微分几何的方法计算高斯曲率，具体实现在PyMesh的C++代码中。

### 曲率计算的输入是mesh


从代码中可以看到，输入是mesh（三角网格）：

```python
def __init__(self, mesh_path, cuda_device = 0):
    self.optix_mesh = optix_mesh()
    self.update_mesh(mesh_path)

def update_mesh(self, mesh_path):
    # 加载mesh文件
    mesh = trimesh.load(mesh_path, process=False)
    self.mesh = mesh
    
    # 获取顶点和面信息
    self.vertices = torch.tensor(mesh.vertices, dtype=Float, device=device)  # 顶点
    self.faces = torch.tensor(mesh.faces, dtype=torch.long, device=device)   # 面
    self.triangles = self.vertices[self.faces] #[Fx3x3]
    
    # 使用PyMesh加载同样的mesh
    self.pymesh_mesh = pymesh.meshio.load_mesh(mesh_path, drop_zero_dim=False)
```

具体来说：
1. 输入是一个mesh文件（如.obj, .ply等格式）
2. mesh包含：
   - vertices（顶点）
   - faces（面，由三个顶点索引组成的三角形）
3. 曲率计算是基于这个三角网格结构进行的，而不是点云
4. PyMesh会利用mesh的拓扑结构（顶点连接关系）来计算每个顶点的高斯曲率

所以这是一个基于mesh的曲率计算，而不是点云的曲率计算。这也更合理，因为mesh提供了表面的连接信息，可以更准确地计算曲率。


### 曲率与透明物折射的关系

在这份代码中，曲率主要用于计算光线在透明物体表面的折射路径。让我看看具体实现：

```python
# 计算曲率半径（曲率的倒数）
curvature_radius = 1 / torch.sqrt(torch.clamp(torch.abs(gaussian_curvature),min=0.000001))
curvature_radius = torch.nan_to_num(curvature_radius,0.1)

# 区分正负曲率
curvature_positive = gaussian_curvature >= 0
curvature_negative = ~curvature_positive

if is_outside:  # 从外部进入物体
    cos_thetat = torch.sqrt(torch.clamp(1 - sin_thetat_2,min=0.0001))
    
    # 处理正曲率的情况（凸面）
    if curvature_positive.sum() > 0:
        costhetat_r = curvature_radius * cos_thetat
        delta2_positive = costhetat_r * costhetat_r - 2 * curvature_radius * thickness + thickness * thickness
        delta_positive = torch.sqrt(torch.clamp(delta2_positive,min = 0.0001))
        length_dt = torch.abs(costhetat_r - delta_positive)
        
        # 计算曲面中心位置和下一个光线起点
        center_position = intersection - normal * curvature_radius
        next_start_tmp_positive = intersection + next_dir_inner * (length_dt.reshape(-1,1) + 0.001)
        
    # 处理负曲率的情况（凹面）
    if curvature_negative.sum() > 0:
        costhetat_r = curvature_radius * cos_thetat
        delta2_negative = costhetat_r * costhetat_r + 2 * curvature_radius * thickness + thickness * thickness
        delta_negative = torch.sqrt(torch.clamp(delta2_negative,min = 0.0001))
        length_dt = torch.abs(costhetat_r - delta_negative)
        
        # 计算曲面中心位置和下一个光线起点
        center_position = intersection + normal * curvature_radius
        next_start_tmp_negative = intersection + next_dir_inner * (length_dt.reshape(-1,1) + 0.001)
```

主要用途：

1. 曲率用于确定表面的形状（凹面或凸面）
2. 曲率半径用于：
   - 计算光线在曲面上的传播距离
   - 确定曲面的中心位置
   - 计算光线的下一个起点

3. 不同曲率类型的处理：
   - 正曲率（凸面）：光线向外弯曲
   - 负曲率（凹面）：光线向内弯曲

4. 结合厚度(thickness)参数，计算光线在透明物体内的传播路径

这种处理方式考虑了曲面的几何特性对光线传播的影响，使得渲染结果更接近真实的物理现象。

### 曲率估计折射路径长度

对于一个曲面上的折射，主要涉及以下几个步骤：

1. **首先是斯涅尔定律（Snell's law）**：
   $$
   n_1 \sin(\theta_i) = n_2 \sin(\theta_t)
   $$
   在代码中表现为：
   ```python
   sin_thetat_2 = sin_thetai_2 * ior_ratio * ior_ratio  # ior_ratio = \frac{n_1}{n_jjjj
   2}
   ```

2. **对于曲面，关键是计算光线在曲面上的传播**。假设曲率半径为$R$（$R = \frac{1}{\sqrt{|K|}}$，$K$为高斯曲率），则：

   - 对于凸面（正曲率）：
     $$
     \cos(\theta_t R) = \pm \sqrt{R^2 \cos^2(\theta_t) - 2Rt + t^2}
     $$
     在代码中：
     ```python
     costhetat_r = curvature_radius * cos_thetat
     delta2_positive = costhetat_r * costhetat_r - 2 * curvature_radius * thickness + thickness * thickness
     ```

3. **光线传播距离**：
   $$
   d = \left| R \cos(\theta_t) - \sqrt{R^2 \cos^2(\theta_t) - 2Rt + t^2} \right|
   $$
   代码实现：
   ```python
   length_dt = torch.abs(costhetat_r - delta_positive)
   ```

4. **对于凹面（负曲率），公式变为**：
   $$
   \cos(\theta_t R) = \pm \sqrt{R^2 \cos^2(\theta_t) + 2Rt + t^2}
   $$
   代码实现：
   ```python
   delta2_negative = costhetat_r * costhetat_r + 2 * curvature_radius * thickness + thickness * thickness
   ```

5. **曲面中心的位置计算**：
   - 凸面：$P_{\text{center}} = P - Rn$
   - 凹面：$P_{\text{center}} = P + Rn$
   其中：
   - $P$是交点位置
   - $n$是表面法线
   - $R$是曲率半径

   代码中：
   ```python
   # 凸面
   center_position = intersection - normal * curvature_radius
   # 凹面
   center_position = intersection + normal * curvature_radius
   ```

这些计算考虑了：
- 表面的局部几何形状（通过高斯曲率）
- 材质的折射率（通过 $ ior_{ratio} $ ）
- 物体的厚度（通过$thickness$）

这样可以更准确地模拟光线在曲面上的折射行为，特别是：
1. 光线在曲面上的偏折
2. 光线在介质中的传播距离
3. 不同曲率（凹凸）对光线路径的影响


### 推导传播距离【sonnet-3.5】

对于一个曲面（以凸面为例）：

假设我们有：
   - 曲率半径 $R$
   - 入射点 $P$
   - 曲面中心 $C$
   - 折射角 $\theta_t$
   - 材料厚度 $t$

我们要找到光线穿过厚度 $t$ 后的出射点 $Q$。这形成了一个几何问题：

   ```
   P: 入射点
   C: 曲面中心
   Q: 出射点
   R: 曲率半径
   $\theta_t$ : 折射角
   t: 厚度

   PC = R (曲率半径)
   PQ = d (我们要求的传播距离)
   CQ = R (因为出射点也在同一曲率半径上)
   ```

根据余弦定理：

 $$
 CQ^2 = CP^2 + PQ^2 - 2 \cdot CP \cdot PQ \cdot \cos\left(\frac{\pi}{2} - \theta_t\right)
 $$

代入已知条件：

$$
R^2 = R^2 + d^2 - 2Rd \cdot \cos\left(\frac{\pi}{2} - \theta_t\right)
$$

$$
R^2 = R^2 + d^2 - 2Rd \cdot \sin(\theta_t)
$$

由于厚度 $t$ 是沿法线方向测量的：

$$
t = d \cdot \cos(\theta_t)
$$

将这个关系代入：

$$
R^2 = R^2 + \left(\frac{t}{\cos(\theta_t)}\right)^2 - 2R\left(\frac{t}{\cos(\theta_t)}\right) \cdot \sin(\theta_t)
$$

整理后得到：

$$
(R \cdot \cos(\theta_t))^2 = (R \cdot \cos(\theta_t))^2 - 2Rt + t^2
$$

因此传播距离 $d$ 为：

$$
d = \left| R \cdot \cos(\theta_t) - \sqrt{(R \cdot \cos(\theta_t))^2 - 2Rt + t^2} \right|
$$

这就是代码中的计算公式：
```python
costhetat_r = curvature_radius * cos_thetat  # R \cdot \cos(\theta_t)
delta2_positive = costhetat_r * costhetat_r - 2 * curvature_radius * thickness + thickness * thickness
delta_positive = torch.sqrt(torch.clamp(delta2_positive, min=0.0001))
length_dt = torch.abs(costhetat_r - delta_positive)
```

对于凹面，推导过程类似，只是几何关系略有不同，导致公式中的 $-2Rt$ 变为 $+2Rt$。

这个公式考虑了：
1. 曲面的几何形状（通过曲率半径 $R$）
2. 折射后光线的传播方向（通过 $\theta_t$）
3. 材料的厚度（通过 $t$）

这样就能准确计算出光线在曲面材料中的实际传播距离。
