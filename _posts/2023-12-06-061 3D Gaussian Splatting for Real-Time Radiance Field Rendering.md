---
layout: mypost
title: 061 3D Gaussian Splatting for Real-Time Radiance Field Rendering
categories: [3DGS]
---

# 文章信息

## 标题

3D Gaussian Splatting for Real-Time Radiance Field Rendering

用于实时辐射场渲染的三维高斯投影方法

## 发表信息

文章发表于2023年的SIGGRAPH，并被评为2023年度的Best Paper.

# 论文链接

- [ACM TOG](https://dl.acm.org/doi/10.1145/3592433)

- [Arxiv](https://arxiv.org/abs/2308.04079)

- [Github](https://github.com/graphdeco-inria/gaussian-splatting)

发表时间：[v1] Tue, 8 Aug 2023 06:37:06 UTC (33,218 KB)

# 文章内容

## 介绍

​18-231206. 3D Gaussian Splatting for Real-Time Radiance Field Rendering. 论文发表于2023年的SIGGRAPH上，并被评为2023年SIGGRAPH的best paper. 文章将无界全范围场景下的新视角合成的速度和质量提上了一个很高的台阶，在训练三万轮（大约半个小时的训练时间）的时候，成像质量堪比或优于MipNeRF360；在训练7千轮（大约6-8分钟）的时候，成像质量也能够优于Instant-NGP。由于采用光栅化高斯球形投影方法，渲染速度能够达到一秒渲染93-135帧，此前最快的Instant-NGP的渲染速度是1秒渲染9帧，Plenoxels每秒8帧，MipNeRF大约十秒渲染一帧，实时渲染的性能相当可观。文章的方法主要由三点构成，第一使用各向异性的三维高斯作为场景的表示方法，在三维空间中朝向不同的高斯球，按照颜色、透明度，向成像平面加权投影，得到成像结果；第二是尺度适应性裁剪，高斯球的大小由协方差矩阵中的方差决定，方差越大表示高斯球的尺寸越大，可以用于表征空间中的大面积同质区域，文章适当地将大尺寸的高斯球分解为小尺寸的高斯球，逐步增强细节表征能力，最终的训练模型能达到场景中300-500k个小高斯球；第三是光栅化渲染算法，光栅化混合算法相比于NeRF的查询MLP更节省计算时间，最大程度提高渲染速度。

# 论文重点难点讲解

### 论文重点和难点

## 1 **研究背景与动机**

- **背景**：神经辐射场（NeRF）技术在多视角图像合成领域取得了显著进展，但现有方法在训练和渲染速度上存在瓶颈，难以实现实时高质量渲染。

- **动机**：本文提出一种基于3D高斯分布的场景表示方法，结合实时可微渲染器，旨在实现高质量的实时辐射场渲染，同时保持与现有最快方法相当的训练时间。

## 2 **关键贡献**

- **3D高斯分布表示**：提出一种新颖的3D高斯分布场景表示方法，能够高效优化并支持快速渲染。该表示方法保留了连续体积辐射场的优化优势，同时避免了空空间的无效计算。

- **优化与密度控制**：通过交错优化3D高斯分布的位置、各向异性协方差和透明度，并动态调整高斯分布的密度，实现了紧凑且精确的场景表示。

- **实时渲染算法**：开发了一种基于瓦片的快速可见性感知渲染算法，支持各向异性高斯分布的“splatting”，加速训练并实现1080p分辨率下的实时渲染。

## 3 **技术细节与难点**

- **3D高斯分布的优化**：

- **难点**：高斯分布的协方差矩阵必须保持正半定性，而直接优化可能导致无效矩阵。为此，作者采用将协方差分解为缩放和旋转矩阵的方式进行优化，避免了这一问题。

- **公式**：高斯分布的协方差矩阵$\Sigma$通过缩放矩阵$S$和旋转矩阵$R$表示为：

$$
\Sigma = R S^2 R^T
$$

其中$S$为缩放矩阵，$R$为旋转矩阵。

- **各向异性高斯分布的渲染**：

- **难点**：如何高效地将3D高斯分布投影到2D屏幕空间，并进行快速排序和混合。

- **解决方案**：通过瓦片化渲染和快速GPU排序算法，实现了各向异性高斯分布的实时渲染。渲染过程中，高斯分布按照深度排序并进行$\alpha$-blending，确保可见性顺序。

- **公式**：高斯分布的2D投影公式为：

$$
\Sigma' = J \Sigma J^T
$$

其中$J$是投影变换的雅可比矩阵。

- **实时渲染与训练效率**：

- **难点**：如何在保持高质量的同时，实现快速训练和实时渲染。

- **解决方案**：通过交错优化和密度控制，以及高效的GPU实现，本文方法在训练速度上与现有最快方法相当，并在渲染速度上实现了显著提升。例如，在1080p分辨率下，本文方法能够达到135fps的实时渲染速度。

## 4 **实验结果与对比**

- **性能对比**：

- 在多个标准数据集上，本文方法在训练时间、渲染速度和图像质量上均优于或接近现有最佳方法。例如，在Mip-NeRF360数据集上，本文方法在30K迭代后达到了25.2fps的渲染速度，而Mip-NeRF360的渲染速度仅为0.07fps。

- **定量结果**：在PSNR、SSIM和LPIPS等指标上，本文方法与Mip-NeRF360相当或略优，同时训练时间大幅缩短。

- **实时性**：本文方法首次实现了在1080p分辨率下高质量的实时辐射场渲染，填补了该领域的空白。

## 5 **局限性与未来工作**

- **局限性**：

- 在未被充分观察的场景区域，本文方法可能会产生伪影。

- 各向异性高斯分布可能导致“拉伸”或“斑点”伪影。

- 内存消耗较高，尤其是在训练大规模场景时。

- **未来工作**：

- 探索更高效的内存管理和优化策略。

- 将高斯分布表示应用于网格重建，以更好地理解其在体积表示和表面表示之间的位置。

- 改进可见性算法以减少伪影。

# 论文详细介绍

### 论文详细讲解：3D Gaussian Splatting for Real-Time Radiance Field Rendering

## 1 **研究背景与动机**

- **背景**：

- 神经辐射场（NeRF）及其变体在多视角合成领域取得了显著成果，但现有方法在训练和渲染速度上存在瓶颈，难以实现实时高质量渲染。

- 现有方法分为两类：一类是高质量但训练和渲染速度慢（如Mip-NeRF360）；另一类是训练和渲染速度快但质量较低（如InstantNGP和Plenoxels）。

- **动机**：

- 提出一种新的方法，结合高质量和实时渲染的优点，实现1080p分辨率下的实时高质量多视角合成。

## 2 **核心贡献**

- **3D高斯分布表示**：

- 使用3D高斯分布作为场景表示，结合各向异性协方差优化，实现紧凑且高效的场景建模。

- 从稀疏的Structure-from-Motion（SfM）点云初始化，避免了复杂的多视图立体（MVS）重建。

- **优化与密度控制**：

- 通过交错优化3D高斯的位置、透明度、各向异性协方差和球谐系数，动态调整高斯分布的密度，避免过拟合和欠拟合。

- **实时渲染算法**：

- 提出一种基于瓦片的快速可见性感知渲染算法，支持各向异性高斯分布的“splatting”，显著加速训练和渲染过程。

- 实现了1080p分辨率下的实时渲染（≥30fps），填补了该领域的空白。

## 3 **技术细节**

- **3D高斯分布的定义与优化**：

- **定义**：

- 每个3D高斯分布由位置（均值）$\mu$、各向异性协方差矩阵$\Sigma$、透明度$\alpha$和球谐系数（用于颜色表示）组成。

- 协方差矩阵$\Sigma$通过缩放矩阵$S$和旋转矩阵$R$表示为：

$$
\Sigma = R S^2 R^T
$$

其中$S$为缩放矩阵，$R$为旋转矩阵。

- **优化**：

- 使用梯度下降优化高斯分布的参数，通过球谐系数表示颜色，避免了神经网络的复杂性。

- 使用各向异性协方差优化，使高斯分布能够更好地适应复杂几何结构，减少参数数量。

- **密度控制与动态调整**：

- **克隆（Clone）与分裂（Split）策略**：

- 对于小尺度几何结构，通过克隆高斯分布来填补缺失区域。

- 对于大尺度高斯分布，通过分裂为多个小高斯分布来提高细节表现。

- **动态调整**：

- 在优化过程中，动态添加或移除高斯分布，以适应场景的复杂性。

- 使用位置梯度的大小作为克隆或分裂的依据。

- **实时渲染算法**：

- **瓦片化渲染**：

- 将屏幕划分为16×16像素的瓦片，对每个瓦片内的高斯分布进行排序和渲染。

- 使用GPU的Radix排序算法对高斯分布进行深度排序，避免逐像素排序的开销。

- **各向异性“splatting”**：

- 将3D高斯分布投影到2D屏幕空间，形成各向异性的椭圆分布。

- 通过$\alpha$-blending进行混合，确保可见性顺序。

- **反向传播**：

- 在反向传播中，通过跟踪每个像素的累积透明度，支持任意数量的高斯分布接收梯度更新。

## 4 **实验与结果**

- **数据集与实验设置**：

- 使用多个标准数据集（如Mip-NeRF360、Tanks&Temples、Deep Blending）进行测试。

- 在A6000 GPU上运行，与Mip-NeRF360、InstantNGP和Plenoxels等方法进行对比。

- **定量结果**：

- **PSNR、SSIM和LPIPS**：

- 在Mip-NeRF360数据集上，本文方法在30K迭代后达到了与Mip-NeRF360相当的PSNR和SSIM值，但训练时间从48小时缩短到35-45分钟。

- 在Tanks&Temples和Deep Blending数据集上，本文方法在PSNR和SSIM上优于InstantNGP和Plenoxels。

- **渲染速度**：

- 本文方法在1080p分辨率下实现了135fps的实时渲染速度，而Mip-NeRF360仅为0.07fps。

- **定性结果**：

- 本文方法在细节保留和背景重建方面优于Mip-NeRF360和InstantNGP。

- 在合成数据集（如Blender数据集）上，本文方法从随机初始化的高斯分布开始，也能快速收敛到高质量的结果。

## 5 **局限性与未来工作**

- **局限性**：

- 在未被充分观察的区域，可能会出现伪影。

- 各向异性高斯分布可能导致“拉伸”或“斑点”伪影。

- 内存消耗较高，尤其是在训练大规模场景时。

- **未来工作**：

- 探索更高效的内存管理和优化策略。

- 将高斯分布表示应用于网格重建，以更好地理解其在体积表示和表面表示之间的位置。

- 改进可见性算法以减少伪影。

## 6 **总结**

本文提出了一种基于3D高斯分布的实时辐射场渲染方法，通过高效的场景表示、优化策略和渲染算法，实现了高质量的实时渲染。该方法在训练时间、渲染速度和图像质量上均优于或接近现有最佳方法，为实时高质量多视角合成提供了一种新的解决方案。

# 论文方法部分详解

## 1 **3D 高斯分布表示**

本文提出了一种基于3D高斯分布的场景表示方法，用于高效优化和快速渲染。每个3D高斯分布由以下参数定义：

- **位置（均值）**：$\mu \in \mathbb{R}^3$

- **各向异性协方差矩阵**：$\Sigma \in \mathbb{R}^{3 \times 3}$，用于表示高斯分布的形状和方向。

- **透明度**：$\alpha \in [0, 1]$

- **球谐系数**：用于表示颜色信息，支持视图依赖的外观。

**关键点**：

- 3D高斯分布是一种连续的体积表示，能够高效地表示复杂场景，同时避免了空空间的无效计算。

- 与传统的点云表示相比，3D高斯分布通过各向异性协方差矩阵能够更紧凑地表示几何细节。

## 2 **从SfM点云初始化**

输入为一组校准好的多视角图像及其对应的稀疏SfM点云。初始化步骤如下：

- 使用SfM点云作为初始的3D高斯分布中心（均值）。

- 初始协方差矩阵设置为各向同性，大小基于邻近点的距离。

- 初始透明度$\alpha$设置为较小值，以便在优化过程中逐渐调整。

**公式**：

初始协方差矩阵$\Sigma_0$为：

$$
\Sigma_0 = \sigma_0^2 \mathbf{I}_3
$$

其中，$\sigma_0$是基于邻近点距离的标量，$\mathbf{I}_3$是3×3单位矩阵。

## 3 **优化与密度控制**

优化过程的目标是调整3D高斯分布的参数，以最小化渲染图像与训练视图之间的差异。优化步骤如下：

### 3.1 **参数优化**

- 使用随机梯度下降（SGD）优化3D高斯分布的位置、各向异性协方差、透明度和球谐系数。

- 透明度$\alpha$通过sigmoid激活函数约束在$[0, 1]$范围内。

- 协方差矩阵的优化通过分解为缩放矩阵$S$和旋转矩阵$R$实现：

$$
\Sigma = R S^2 R^T
$$

- 优化过程中使用$L_1$损失和D-SSIM损失的组合：

$$
L = (1 - \epsilon) L_1 + \epsilon L_{\text{D-SSIM}}
$$

其中，$\epsilon$为平衡参数。

### 3.2 **密度控制**

- **动态调整高斯分布的数量**：通过克隆（Clone）和分裂（Split）策略动态调整高斯分布的密度。

- **克隆**：对于小尺度高斯分布，通过复制并移动来填补缺失区域。

- **分裂**：对于大尺度高斯分布，将其分裂为多个小高斯分布，以提高细节表现。

- **去除无效高斯分布**：移除透明度小于阈值$\alpha_{\text{thresh}}$的高斯分布。

**公式**：

- 分裂策略中，新高斯分布的缩放因子为：

$$
S_{\text{new}} = \frac{S_{\text{old}}}{\pi_s}
$$

其中，$\pi_s$为实验确定的常数（如1.6）。

## 4 **实时渲染算法**

实时渲染是本文的核心贡献之一，通过以下技术实现高效渲染：

### 4.1 **瓦片化渲染**

- 将屏幕划分为16×16像素的瓦片，对每个瓦片内的高斯分布进行排序和渲染。

- 使用GPU的Radix排序算法对高斯分布按深度排序，避免逐像素排序的开销。

### 4.2 **各向异性“splatting”**

- 将3D高斯分布投影到2D屏幕空间，形成各向异性的椭圆分布。

- 使用$\alpha$-blending进行混合，确保可见性顺序。

**公式**：

高斯分布的2D投影协方差矩阵$\Sigma'$为：

$$
\Sigma' = J \Sigma J^T
$$

其中，$J$是投影变换的雅可比矩阵。

### 4.3 **反向传播**

- 在反向传播中，通过跟踪每个像素的累积透明度，支持任意数量的高斯分布接收梯度更新。

- 通过存储每个像素的最终累积透明度，反向传播时能够恢复中间透明度值，从而计算梯度。

## 5 **总结**

本文提出的方法通过3D高斯分布的场景表示、动态优化与密度控制以及高效的实时渲染算法，实现了高质量的实时辐射场渲染。该方法在训练时间、渲染速度和图像质量上均优于或接近现有最佳方法，为实时高质量多视角合成提供了一种新的解决方案。

# 论文附录部分详解

### 论文附录部分详细讲解

#### **附录A：梯度计算细节**

附录A详细描述了3D高斯分布参数的梯度计算方法，这些梯度用于优化高斯分布的位置、各向异性协方差矩阵、透明度等参数。

- **位置梯度**：

位置梯度的计算基于高斯分布的均值$\mu$对渲染结果的影响。位置梯度的表达式为：

$$
\frac{\partial L}{\partial \mu} = -\sum_{i} \frac{\partial L}{\partial I_i} \cdot \frac{\partial I_i}{\partial \mu}
$$

其中，$L$是损失函数，$I_i$是像素$i$的渲染强度，$\frac{\partial I_i}{\partial \mu}$表示位置变化对像素强度的导数。

- **协方差矩阵梯度**：

协方差矩阵$\Sigma$的梯度计算较为复杂，因为需要保持$\Sigma$的正定性。通过将$\Sigma$分解为缩放矩阵$S$和旋转矩阵$R$，可以更高效地计算梯度：

$$
\Sigma = R S^2 R^T
$$

对应的梯度为：

$$
\frac{\partial L}{\partial S} = 2 \cdot \frac{\partial L}{\partial \Sigma} \cdot S
$$

$$
\frac{\partial L}{\partial R} = \frac{\partial L}{\partial \Sigma} \cdot S^2 \cdot R^T
$$

其中，$\frac{\partial L}{\partial \Sigma}$是损失函数对协方差矩阵的导数。

- **透明度梯度**：

透明度$\alpha$的梯度计算较为直接，主要基于透明度对渲染结果的直接影响：

$$
\frac{\partial L}{\partial \alpha} = -\sum_{i} \frac{\partial L}{\partial I_i} \cdot \frac{\partial I_i}{\partial \alpha}
$$

#### **附录B：优化与密度控制算法**

附录B提供了优化和密度控制算法的伪代码，详细描述了如何通过迭代优化高斯分布的参数，并动态调整高斯分布的数量。

- **算法流程**：

`1.` **初始化**：从SfM点云初始化高斯分布的位置、协方差、透明度和颜色。

`2.` **迭代优化**：

- 采样训练视图并渲染当前高斯分布。

- 计算损失函数$L$并反向传播更新高斯分布参数。

- 每隔一定迭代次数，执行密度控制操作：

- **移除无效高斯分布**：移除透明度小于阈值$\alpha_{\text{thresh}}$或尺寸过大的高斯分布。

- **克隆与分裂**：根据位置梯度的大小，决定克隆小高斯分布或分裂大高斯分布。

`3.` **结束条件**：当损失函数收敛或达到最大迭代次数时停止优化。

#### **附录C：光栅化细节**

附录C详细描述了基于瓦片的光栅化算法，用于高效渲染3D高斯分布。

- **瓦片化与排序**：

- 将屏幕划分为16×16像素的瓦片。

- 对每个高斯分布计算其投影到屏幕空间的深度，并分配一个“键值”（key），其中低32位表示深度，高32位表示瓦片索引。

- 使用GPU的Radix排序算法对所有高斯分布进行全局排序。

- **渲染流程**：

- 对每个瓦片，根据排序结果生成高斯分布列表。

- 按深度顺序对每个像素进行$\alpha$-blending混合，确保可见性顺序。

- 在反向传播中，通过存储每个像素的累积透明度，支持任意数量的高斯分布接收梯度更新。

- **数值稳定性**：

- 在混合过程中，跳过透明度小于阈值（如$\frac{1}{255}$）的高斯分布，避免数值不稳定。

- 对透明度进行上界钳制（如0.99），防止累积透明度过高。

#### **附录D：每场景误差指标**

附录D提供了在不同数据集上，本文方法与其他方法（如Mip-NeRF360、InstantNGP、Plenoxels）的详细对比结果，包括PSNR、SSIM和LPIPS等指标。

- **数据集**：

- Mip-NeRF360数据集：包括多个复杂场景，如“bicycle”、“garden”、“room”等。

- Tanks&Temples数据集：包含大规模室外场景。

- Deep Blending数据集：包含室内场景。

- **对比结果**：

- 本文方法在多个场景中达到了与Mip-NeRF360相当的PSNR和SSIM值，但在训练时间上大幅缩短（从48小时缩短到35-45分钟）。

- 在渲染速度上，本文方法实现了1080p分辨率下的实时渲染（≥30fps），而Mip-NeRF360仅为0.07fps。

- 在Tanks&Temples和Deep Blending数据集上，本文方法在PSNR和SSIM上优于InstantNGP和Plenoxels。

通过附录部分的详细描述，论文展示了其方法在优化、渲染和结果评估方面的具体实现细节，为读者提供了完整的实现参考。