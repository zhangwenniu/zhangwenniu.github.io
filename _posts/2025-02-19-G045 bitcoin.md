---
layout: mypost
title: G045 Bitcoin, A Peer-to-Peer Electronic Cash System
categories: [bitcoin]
---

# 链接

- [Bitcoin: A Peer-to-Peer Electronic Cash System](https://bitcoin.org/en/bitcoin-paper)

# 难点解释

## 什么是“双重支付”？

“双重支付”（Double-Spending）是数字货币领域的一个核心问题，指的是用户试图将同一笔数字货币重复使用两次或多次的行为。在传统的金融系统中，这种问题几乎不存在，因为金融机构（如银行）会记录每一笔交易，并确保资金从一个账户转移到另一个账户，从而避免重复使用。然而，在数字货币（如比特币）的环境中，由于交易是去中心化的，没有中央机构来验证交易的唯一性，因此双重支付成为了一个需要解决的关键问题。

### 举例说明
假设Alice拥有一笔价值1 BTC的数字货币。她试图将这1 BTC同时支付给Bob和Charlie，这就构成了双重支付。具体来说：
1. Alice向Bob发起一笔交易，将1 BTC发送给Bob。
2. 同时，Alice向Charlie发起另一笔交易，将同一笔1 BTC发送给Charlie。

如果这两笔交易都被网络接受，那么Bob和Charlie都会认为他们各自收到了1 BTC，但实际上Alice试图重复使用了同一笔资金。这种行为不仅会导致经济上的混乱，还会破坏数字货币系统的可信度。

### 为什么双重支付是问题？
在去中心化的数字货币系统中，没有中央机构来验证交易是否重复。因此，双重支付可能会导致以下问题：
1. **经济混乱**：接收方可能无法确定他们收到的资金是否真实有效。
2. **信任缺失**：如果双重支付问题得不到解决，用户将对数字货币系统失去信任。
3. **资源浪费**：矿工可能会浪费算力去处理无效的交易。

### 比特币如何解决双重支付问题？
比特币通过以下机制解决了双重支付问题：
1. **区块链（Blockchain）**：
   - 比特币的交易记录被存储在一个去中心化的账本——区块链中。
   - 每个区块包含一组交易，通过哈希值链接到前一个区块，形成一个不可篡改的链。

2. **工作量证明（Proof-of-Work, PoW）**：
   - 矿工需要通过计算难题（工作量证明）来生成新区块。
   - 一旦一个区块被添加到区块链中，后续的矿工会在该区块的基础上继续工作，从而进一步确认该区块中的交易。

3. **最长链规则**：
   - 比特币网络中的节点总是接受最长的区块链作为“真实”记录。
   - 如果一个双重支付尝试被发现，只有被大多数节点认可的交易才会被记录在最长链中。

4. **交易确认**：
   - 一笔交易需要经过多个区块确认（通常6个或更多）才被认为是安全的。
   - 随着确认区块数的增加，攻击者篡改交易记录的概率呈指数级下降。

### 数学上的解释
假设攻击者试图通过控制算力来篡改交易记录：
- 如果攻击者的算力占比为 $q$，诚实节点的算力占比为 $p$（$p + q = 1$），那么攻击者追上诚实链的概率会随着落后区块数 $z$ 的增加而呈指数级下降。
- 例如，当攻击者的算力占比为10%（$q = 0.1$），落后6个区块时，攻击者追上的概率仅为0.00024。

因此，比特币通过增加区块确认数量，极大地提高了交易的安全性，使得双重支付在实际中几乎不可能成功。

### 总结
双重支付是数字货币中一个关键的经济问题，比特币通过区块链、工作量证明和最长链规则等机制，有效地解决了这一问题，确保了交易的安全性和系统的可信度。


## 完全不可逆的交易实际上是不存在的，因为金融机构无法避免调解争议。

这句话怎么理解？

### 1. **不可逆交易的定义**
不可逆交易（Irreversible Transaction）是指一旦完成，就无法被撤销或更改的交易。在理想的支付系统中，不可逆交易可以为收款方提供极高的安全性，因为他们可以确信收到的资金不会因为任何原因被退回或撤销。

### 2. **传统金融系统中的交易可逆性**
在传统的金融系统中，交易通常是可逆的，原因在于：
- **金融机构的介入**：金融机构（如银行）作为交易的中间方，负责处理和记录每一笔交易。
- **调解争议的需求**：金融机构需要处理各种交易争议，例如：
  - 买家声称收到的商品与描述不符。
  - 交易被错误地执行。
  - 交易涉及欺诈行为。

为了保护消费者权益，金融机构通常会介入这些争议，并可能撤销或调整交易。因此，传统金融系统中的交易并不是完全不可逆的。

### 3. **这句话的含义**
“完全不可逆的交易实际上是不存在的，因为金融机构无法避免调解争议。”这句话的意思是：
- 在传统金融系统中，**交易的不可逆性是有限的**。金融机构需要保留撤销或调整交易的能力，以应对各种可能出现的争议。
- 金融机构作为中间方，必须在交易中保持一定的灵活性，以便在必要时进行调解。这种灵活性导致了交易的可逆性。
- 因此，**完全不可逆的交易在传统金融系统中是无法实现的**，因为金融机构需要处理各种复杂的交易场景，而这些场景可能需要对交易进行调整。

### 4. **对比特币的启示**
比特币作为一种去中心化的数字货币，试图通过技术手段（如区块链和工作量证明）实现一种**接近不可逆的交易机制**：
- 一旦交易被记录在区块链上，并经过多个区块确认，这笔交易就几乎无法被撤销或更改。
- 这种设计为收款方提供了更高的安全性，因为他们可以确信收到的资金不会被轻易退回。
- 然而，比特币的交易也不是绝对不可逆的。如果攻击者能够控制超过50%的网络算力（虽然难度极高），理论上仍然可以篡改交易记录。

### 5. **总结**
这句话强调了传统金融系统中交易可逆性的现实限制。金融机构需要处理各种交易争议，因此无法实现完全不可逆的交易。比特币通过去中心化的设计，试图解决这一问题，但仍然存在理论上的可逆性风险。这种对比揭示了传统金融系统和比特币在交易安全性上的不同设计思路。


## Proof-of-Work原理

工作量证明涉及扫描一个值，当对其进行哈希处理时（例如使用SHA-256），哈希值以一定数量的零位开头。所需的零位数量越多，平均工作量呈指数增长，而验证只需执行一次哈希。

怎么理解这句话？

### 1. **工作量证明（Proof-of-Work, PoW）**
工作量证明是一种机制，用于确保在比特币网络中生成新区块需要付出一定的计算努力（即“工作量”）。这种机制的主要目的是防止恶意攻击者通过简单的重复攻击来篡改交易记录或生成无效区块。

### 2. **扫描一个值**
在比特币中，矿工需要找到一个特定的值（称为**随机数**或**nonce**），使得这个值满足某种条件。具体来说，矿工需要将区块头（包含交易信息、前一个区块的哈希值等）和随机数一起进行哈希运算。

### 3. **哈希值以一定数量的零位开头**
哈希函数（如SHA-256）将输入数据转换为一个固定长度的输出（哈希值）。在比特币中，矿工的目标是找到一个随机数，使得区块头的哈希值以一定数量的零位开头。例如，目标可能是找到一个哈希值以 **10个零位** 开头。

### 4. **所需的零位数量越多，平均工作量呈指数增长**
哈希函数的输出是随机的，因此找到一个以特定数量零位开头的哈希值需要多次尝试。零位的数量越多，找到满足条件的哈希值就越困难。具体来说：
- 如果目标是找到一个以 **1个零位** 开头的哈希值，可能只需要尝试 **2次**。
- 如果目标是找到一个以 **2个零位** 开头的哈希值，可能需要尝试 **4次**。
- 如果目标是找到一个以 **10个零位** 开头的哈希值，可能需要尝试 **$2^{10}$ 次**。

每增加一个零位，所需的平均尝试次数就会翻倍。因此，零位的数量越多，工作量呈指数级增长。

### 5. **验证只需执行一次哈希**
虽然生成一个满足条件的哈希值需要大量的尝试，但验证这个哈希值是否满足条件却非常简单。其他节点只需要将矿工提供的随机数和区块头一起进行一次哈希运算，检查结果是否以指定数量的零位开头即可。



### 举例说明
假设目标是找到一个以 **4个零位** 开头的哈希值（即以 `0000` 开头）。矿工需要进行以下步骤：

1. **选择一个随机数（nonce）**：例如，随机数为 `12345`。
2. **将区块头和随机数一起哈希**：假设区块头为 `block_header`，矿工计算 `SHA-256(block_header + 12345)`。
3. **检查哈希值是否满足条件**：如果哈希值为 `0000abcde...`，则满足条件；否则，矿工需要尝试下一个随机数（如 `12346`），并重复上述步骤。

矿工需要不断尝试不同的随机数，直到找到一个满足条件的哈希值。这个过程可能需要尝试 **$2^{4} = 16$ 次**（平均而言）。

### 验证过程
其他节点验证这个哈希值是否有效时，只需要：
1. 取出矿工提供的随机数（如 `12345`）。
2. 将区块头和随机数一起哈希：计算 `SHA-256(block_header + 12345)`。
3. 检查结果是否以 `0000` 开头。如果是，验证通过。



### 总结
这句话的核心在于：
- **生成满足条件的哈希值需要大量的计算尝试**，这确保了生成新区块需要付出实际的计算工作。
- **验证这个哈希值是否满足条件非常简单**，只需要一次哈希运算。

这种机制使得比特币网络能够安全地生成新区块，同时防止恶意攻击者轻易篡改交易记录。


## 节点和区块的区别

在比特币网络中，**节点**和**区块**是两个核心概念，它们在功能和作用上有明显的区别。以下是对它们的详细解释：



### 1. 节点（Node）
**节点**是比特币网络中的一个计算设备（如计算机、服务器或智能手机），它们共同构成了比特币的去中心化网络。节点的主要功能包括：

#### （1）**存储区块链数据**
每个节点都保存了一份完整的区块链副本，记录了从创世区块（Genesis Block）开始的所有交易历史。这使得比特币网络无需中央服务器，每个节点都可以独立验证交易和区块的有效性。

#### （2）**验证交易和区块**
节点负责验证网络中传播的交易和区块是否符合比特币协议的规则。例如：
- 交易是否由有效签名发起。
- 交易中的输入是否未被消费（即防止双重支付）。
- 区块是否满足工作量证明（Proof-of-Work）的要求。

#### （3）**传播交易和区块**
节点将新交易广播到网络中的其他节点，并将新生成的区块传播到整个网络。这种传播机制确保了所有节点都能及时更新区块链数据。

#### （4）**参与共识机制**
节点通过工作量证明机制达成共识，即接受最长的区块链作为“真实”记录。如果一个节点发现了一个新区块，它会将该区块广播到网络中，其他节点会验证该区块的有效性，并在确认后将其添加到自己的区块链副本中。

#### （5）**去中心化特性**
节点的存在使得比特币网络去中心化。没有单一的控制点，网络的安全性和可靠性由所有节点共同维护。即使部分节点被攻击或离线，网络仍然可以正常运行。



### 2. 区块（Block）
**区块**是比特币区块链的基本单位，它是一个包含一组交易的数据结构。区块的主要功能和特点如下：

#### （1）**存储交易**
每个区块包含一组经过验证的交易记录。这些交易被组织成一棵梅克尔树（Merkle Tree），以便高效地验证交易的存在。

#### （2）**链接到区块链**
区块通过包含前一个区块的哈希值（`Prev Hash`）链接到区块链中。这种链式结构确保了区块链的不可篡改性。如果一个区块被篡改，其哈希值会发生变化，从而导致后续所有区块的哈希值无效。

#### （3）**工作量证明（Proof-of-Work）**
每个区块都包含一个随机数（`Nonce`），矿工需要通过计算找到一个满足特定条件的哈希值（如以一定数量的零位开头）。这个过程称为工作量证明，它确保了生成新区块需要付出一定的计算工作。

#### （4）**区块头（Block Header）**
区块头是区块的元数据部分，包含以下信息：
- **版本号（Version）**：表示比特币协议的版本。
- **前一个区块的哈希值（Prev Hash）**：链接到前一个区块。
- **梅克尔根（Merkle Root）**：交易的哈希摘要。
- **时间戳（Timestamp）**：区块生成的时间。
- **难度目标（Bits）**：当前工作量证明的难度目标。
- **随机数（Nonce）**：用于工作量证明的值。

#### （5）**区块奖励**
矿工成功生成一个新区块后，会获得一定的奖励，包括：
- **新生成的比特币**：作为激励机制，鼓励矿工维护网络。
- **交易费用**：用户在交易中支付的费用，矿工可以选择优先处理费用较高的交易。



### 3. 节点和区块的区别

#### （1）**功能上的区别**
- **节点**：是网络中的计算设备，负责存储、验证、传播和维护区块链数据。
- **区块**：是区块链的基本单位，用于存储和组织交易数据。

#### （2）**角色上的区别**
- **节点**：是比特币网络的参与者，可以是矿工节点（生成新区块）、全节点（验证和传播交易）、轻节点（仅存储区块头）等。
- **区块**：是数据结构，由矿工生成并添加到区块链中。

#### （3）**数量上的区别**
- **节点**：数量众多，比特币网络中有成千上万的节点。
- **区块**：数量有限，截至2025年，比特币区块链大约有80万个区块。

#### （4）**安全性上的区别**
- **节点**：通过共识机制（如最长链规则）确保网络的安全性。
- **区块**：通过工作量证明和链式结构确保数据的不可篡改性。



### 总结
- **节点**是比特币网络的基础设施，负责维护和传播区块链数据。
- **区块**是区块链的基本单位，用于存储和组织交易数据。
- 节点通过工作量证明机制生成新区块，并通过共识机制确保区块链的安全性和一致性。

理解节点和区块的区别有助于更好地理解比特币网络的运行机制和去中心化特性。


## 只有生成一个区块，才能把比特币花出去吗？

在比特币系统中，**生成一个区块并不是“花费比特币”的必要条件**。实际上，比特币的交易过程和区块生成是两个相对独立但又紧密相关的机制。以下是对这个问题的详细解释：



### 1. **比特币的交易过程**
比特币的交易过程可以分为以下几个步骤：

#### （1）**创建交易**
用户（如Alice）可以通过比特币钱包创建一笔交易，将一定数量的比特币发送给另一个用户（如Bob）。这笔交易包含以下信息：
- **输入（Inputs）**：指明Alice从哪里获取比特币（即引用之前收到比特币的交易）。
- **输出（Outputs）**：指明Alice要将比特币发送给谁（即Bob的地址）。
- **签名（Signatures）**：Alice用自己的私钥对交易进行签名，证明她有权使用这些比特币。

#### （2）**广播交易**
Alice将这笔交易广播到比特币网络中。网络中的节点会验证这笔交易是否有效（例如，签名是否正确，输入的比特币是否未被消费等）。

#### （3）**交易的确认**
节点验证交易有效后，会将这笔交易放入一个**内存池（Mempool）**，等待矿工将其打包进区块。

#### （4）**区块生成**
矿工从内存池中选择交易，将它们打包进一个新的区块。矿工需要通过工作量证明（Proof-of-Work）找到一个满足条件的哈希值，将这个区块添加到区块链中。

#### （5）**交易确认**
当矿工成功生成一个新区块并将其广播到网络中后，这个区块中的交易就被认为是“确认”的。随着后续更多区块的生成，交易的确认程度会进一步增加。



### 2. **花费比特币的条件**
从上述过程可以看出，Alice并不需要自己生成一个区块来花费比特币。她只需要：
- **创建并广播交易**：将交易发送到网络中。
- **等待矿工确认**：矿工将她的交易打包进一个区块。

因此，**花费比特币的关键在于创建和广播交易**，而不是生成区块。生成区块是矿工的工作，而不是普通用户的责任。



### 3. **为什么需要区块确认？**
虽然Alice不需要生成区块来花费比特币，但交易需要被矿工打包进区块并确认，原因在于：
- **防止双重支付**：只有当交易被记录在区块链中，才能确保Alice不会将同一笔比特币重复花费。
- **网络共识**：通过区块确认，网络中的所有节点都能达成一致，确认这笔交易是有效的。



### 4. **交易的确认次数**
在比特币网络中，交易的安全性随着确认次数的增加而提高：
- **0次确认**：交易在内存池中，尚未被打包进区块，存在被撤销的风险。
- **1次确认**：交易被打包进一个区块，但仍可能被攻击者逆转（尤其是在网络算力分布不均的情况下）。
- **6次确认**：交易被记录在6个区块之后，被认为是高度安全的，攻击者逆转交易的可能性极低。



### 5. **总结**
**只有生成一个区块，才能把比特币花出去吗？**
- **答案是否定的**。用户只需要创建并广播交易，矿工将交易打包进区块并确认后，比特币就被成功“花费”了。
- **生成区块是矿工的工作**，而不是普通用户的责任。
- **交易的安全性依赖于区块确认**，但用户不需要自己生成区块来完成交易。

这种设计使得比特币网络既去中心化，又能够高效地处理交易，同时防止双重支付等问题。


## 比特币交易确认需要多久？

比特币交易的确认时间取决于几个因素，主要包括网络的拥堵程度、交易的优先级（通常由交易费用决定），以及矿工的挖矿速度。以下是对这个问题的详细解释：

### 1. **交易费用（Transaction Fee）**
交易费用是用户支付给矿工的费用，用于激励矿工将交易打包进区块。交易费用越高，交易被矿工优先处理的可能性越大，从而确认时间越短。

### 2. **网络拥堵（Network Congestion）**
当比特币网络中待处理的交易量较大时，网络会出现拥堵。在这种情况下，矿工的内存池（Mempool）中会积压大量交易，导致新交易的确认时间延长。

### 3. **矿工的挖矿速度（Mining Speed）**
矿工的挖矿速度决定了新区块的生成速度。如果矿工的算力较强，可以更快地找到满足工作量证明条件的哈希值，从而生成新区块并确认交易。

### 4. **平均确认时间**
在正常情况下，比特币网络的目标是每10分钟生成一个新区块。因此，一笔交易的平均确认时间大约为10分钟。然而，这只是一个平均值，实际确认时间可能因上述因素而有所不同。

### 5. **确认次数**
为了确保交易的安全性，通常需要等待多个区块的确认。例如，6个区块的确认通常被认为是高度安全的，这意味着交易需要等待大约60分钟（6个区块 × 10分钟/区块）。

### 6. **加速确认**
如果用户希望加快交易的确认速度，可以采取以下措施：
- **提高交易费用**：支付更高的交易费用，以获得矿工的优先处理。
- **使用加速服务**：一些比特币钱包和交易平台提供加速服务，可以帮助用户更快地确认交易。

### 7. **总结**
比特币交易的确认时间受交易费用、网络拥堵和矿工挖矿速度的影响。在正常情况下，交易的平均确认时间为10分钟，但为了确保安全性，通常需要等待6个区块的确认，即大约60分钟。如果用户希望加快确认速度，可以提高交易费用或使用加速服务。

因此，比特币交易的确认时间并不是固定的，而是根据网络状况和用户选择的交易费用而变化。

## 激励机制

User: The incentive can also be funded with transaction fees. If the output value of a transaction is less than its input value, the difference is a transaction fee that is added to the incentive value of the block containing the transaction. Once a predetermined number of coins have entered circulation, the incentive can transition entirely to transaction fees and be completely inflation free.
怎么理解？
Kimi: 这段话描述了比特币系统中激励机制（incentive mechanism）的两个主要部分：区块奖励（block reward）和交易费用（transaction fees）。理解这段话的关键在于明确比特币是如何激励矿工维护网络的，以及这种激励机制如何随着时间变化。以下是详细解释：

---

### 1. **激励机制（Incentive Mechanism）**
比特币网络需要矿工（miners）来维护和保护网络，具体工作包括：
- **验证交易**：确保交易的有效性。
- **生成新区块**：通过工作量证明（Proof-of-Work）找到满足条件的哈希值，将交易打包进区块。
- **维护区块链**：将新区块添加到区块链中，确保网络的去中心化和安全性。

为了激励矿工完成这些工作，比特币系统提供了两种主要的激励方式：
1. **区块奖励（Block Reward）**  
2. **交易费用（Transaction Fees）**

---

### 2. **区块奖励（Block Reward）**
区块奖励是比特币系统中最初的主要激励方式。当矿工成功生成一个新区块时，他们会被奖励一定数量的新比特币。这些新比特币是系统新生成的，因此会增加比特币的总供应量。

- **创世区块**：比特币的创世区块（Genesis Block）诞生于2009年，最初的区块奖励是50个比特币。
- **减半机制**：比特币的区块奖励每四年减半一次。例如：
  - 2009-2012年：每个区块奖励50 BTC。
  - 2012-2016年：每个区块奖励25 BTC。
  - 2016-2020年：每个区块奖励12.5 BTC。
  - 2020-2024年：每个区块奖励6.25 BTC。
  - 2024年之后：区块奖励将进一步减半。

随着区块奖励的不断减半，新比特币的生成速度逐渐降低，最终趋于零。这种设计使得比特币的总供应量接近2100万枚，具有一定的稀缺性。

---

### 3. **交易费用（Transaction Fees）**
交易费用是用户支付给矿工的费用，用于激励矿工优先处理他们的交易。交易费用的引入是为了：
- **激励矿工**：即使区块奖励逐渐减少，矿工仍然可以通过交易费用获得收入。
- **优先处理**：交易费用越高，矿工越有可能优先将该交易打包进区块。

交易费用的计算方式是：
- **输入值（Input Value）**：用户在交易中引用的比特币数量。
- **输出值（Output Value）**：用户实际发送给收款人的比特币数量。
- **交易费用（Transaction Fee）**：输入值减去输出值的差额。

例如：
- 用户Alice有1 BTC。
- 她想发送0.9 BTC给Bob。
- 她将1 BTC作为输入，0.9 BTC作为输出，剩下的0.1 BTC作为交易费用。

这笔交易的交易费用（0.1 BTC）会被矿工收取，并添加到他们生成的区块中。

---

### 4. **激励机制的转变**
随着比特币网络的发展，区块奖励逐渐减少，交易费用的重要性逐渐增加。这段话中提到的“激励机制可以完全过渡到交易费用”意味着：
- **初期**：比特币的激励主要依赖于区块奖励。
- **后期**：随着区块奖励逐渐减少，交易费用将成为矿工的主要收入来源。
- **最终**：当所有比特币（2100万枚）都被挖出后，矿工的收入将完全依赖于交易费用。

这种机制确保了比特币网络的长期可持续性，即使没有新的比特币生成，矿工仍然可以通过交易费用获得收入，维持网络的安全性和稳定性。

---

### 5. **完全无通胀（Completely Inflation Free）**
比特币的总供应量是固定的（2100万枚），这意味着比特币的货币供应不会无限增加。与传统的法定货币不同，比特币不会因为央行的印钞行为而产生通胀。因此，当比特币的激励机制完全过渡到交易费用时，它将实现“完全无通胀”的状态。

---

### 总结
这段话的核心在于：
- 比特币的激励机制包括区块奖励和交易费用。
- 区块奖励随着时间逐渐减少，而交易费用的重要性逐渐增加。
- 最终，比特币的激励机制将完全依赖于交易费用，实现无通胀的经济模型。

这种设计不仅确保了比特币网络的长期可持续性，还为用户提供了去中心化和安全的交易环境。

# 梅克尔树（Merkle Tree）


User: 讲一讲梅克尔树（Merkle Tree）
Kimi: 梅克尔树（Merkle Tree），也称为哈希树（Hash Tree），是一种用于高效、安全地验证大量数据完整性的树形数据结构。它在比特币和其他区块链技术中被广泛应用，用于优化数据存储和验证过程。以下是对梅克尔树的详细讲解：

---

### 1. **梅克尔树的基本概念**
梅克尔树是一种二叉树结构，其每个节点都包含一个哈希值。从底层的交易数据开始，通过逐层哈希的方式构建，最终形成一个树状结构。其主要特点如下：

- **叶节点（Leaf Nodes）**：存储实际的交易数据的哈希值。
- **非叶节点（Non-Leaf Nodes）**：存储其子节点哈希值的哈希值。
- **根节点（Root Node）**：树的最顶层节点，其哈希值是整个树的最终哈希值，也称为梅克尔根（Merkle Root）。

---

### 2. **梅克尔树的构建过程**
假设我们有4笔交易（T1, T2, T3, T4），以下是构建梅克尔树的步骤：

#### （1）**计算叶节点的哈希值**
- 对每笔交易进行哈希计算，得到叶节点的哈希值：
  - H(T1)：交易1的哈希值
  - H(T2)：交易2的哈希值
  - H(T3)：交易3的哈希值
  - H(T4)：交易4的哈希值

#### （2）**逐层向上构建**
- 将相邻的叶节点哈希值配对，计算它们的哈希值，形成上一层的节点：
  - H1 = H(H(T1) || H(T2))  （`||` 表示连接）
  - H2 = H(H(T3) || H(T4))
- 继续向上层构建，直到只剩下一个节点：
  - Merkle Root = H(H1 || H2)

最终，整个树的结构如下：

```
          Merkle Root
               |
          +----+----+
          |         |
         H1        H2
       /   \      /   \
     H(T1) H(T2) H(T3) H(T4)
```

---

### 3. **梅克尔树的作用**

#### （1）**高效验证交易的存在**
- **轻客户端（Light Client）**：不需要存储整个区块链，只需存储区块头（包含梅克尔根）。
- **验证交易**：通过提供梅克尔路径（Merkle Path），可以验证某笔交易是否被包含在区块中，而无需下载整个区块。
- **梅克尔路径**：从叶节点到根节点的路径上的哈希值序列，用于证明某笔交易的存在。

例如，验证交易T1的存在：
- 提供H(T2)、H2和Merkle Root。
- 计算：H(H(T1) || H(T2)) → H1 → H(H1 || H2) → Merkle Root。
- 如果计算结果与区块头中的Merkle Root一致，则证明T1被包含在区块中。

#### （2）**节省存储空间**
- 区块头仅需存储梅克尔根，而不需要存储所有交易的哈希值。
- 旧的交易数据可以被丢弃，而通过梅克尔树的结构，仍然可以验证交易的存在。

#### （3）**提高安全性**
- 任何对交易数据的修改都会导致哈希值的变化，从而影响梅克尔根。
- 通过验证梅克尔根，可以确保区块中的交易数据未被篡改。

---

### 4. **梅克尔树的示例**
假设我们有以下4笔交易：
- T1: Alice → Bob, 1 BTC
- T2: Charlie → Dave, 0.5 BTC
- T3: Eve → Frank, 2 BTC
- T4: George → Helen, 0.2 BTC

构建梅克尔树的过程如下：
1. 计算叶节点的哈希值：
   - H(T1) = SHA-256(T1)
   - H(T2) = SHA-256(T2)
   - H(T3) = SHA-256(T3)
   - H(T4) = SHA-256(T4)

2. 计算上一层的哈希值：
   - H1 = SHA-256(H(T1) || H(T2))
   - H2 = SHA-256(H(T3) || H(T4))

3. 计算梅克尔根：
   - Merkle Root = SHA-256(H1 || H2)

最终，区块头中只存储梅克尔根，而不需要存储所有交易的哈希值。

---

### 5. **梅克尔树的优缺点**

#### **优点**
- **高效验证**：轻客户端可以通过梅克尔路径快速验证交易的存在。
- **节省空间**：区块头只需存储梅克尔根，节省存储空间。
- **增强安全性**：任何对交易数据的篡改都会被检测到。

#### **缺点**
- **构建复杂**：需要逐层计算哈希值，构建过程相对复杂。
- **依赖哈希函数**：安全性依赖于哈希函数的抗碰撞性。

---

### 6. **总结**
梅克尔树是一种高效的树形数据结构，广泛应用于比特币和其他区块链技术中。它通过逐层哈希的方式构建，能够高效地验证交易的存在，节省存储空间，并增强数据的安全性。梅克尔树的核心在于其根节点（Merkle Root），它为区块链提供了一种简洁而强大的验证机制。

## Fan-out

User: 交易的“扇出”（fan-out）是什么意思
Kimi: 在比特币和其他区块链技术中，**交易的“扇出”（Fan-out）** 是一个描述交易依赖关系的概念，用来说明一笔交易可能依赖于多笔之前的交易，而这些交易又可能依赖于更多的交易。这种结构类似于树形结构的“分支”（branching），因此被称为“扇出”。

以下是“扇出”的详细解释：

---

### 1. **交易的依赖关系**
在比特币中，每一笔交易都可能依赖于一笔或多笔之前的交易。具体来说：
- **输入（Inputs）**：交易的输入部分引用了之前交易的输出（UTXO，未消费的交易输出）。
- **输出（Outputs）**：交易的输出部分指定了比特币的接收方和金额。

例如：
- 交易A将比特币发送给Alice。
- Alice将这些比特币的一部分发送给Bob（交易B），另一部分发送给Charlie（交易C）。

在这个例子中：
- 交易B和交易C都依赖于交易A（因为它们的输入来自交易A的输出）。

---

### 2. **什么是“扇出”？**
“扇出”描述的是这种依赖关系的扩展性。具体来说，一笔交易可能被多个后续交易引用，而这些后续交易又可能被更多的交易引用。这种结构类似于树形结构的分支，因此被称为“扇出”。

例如：
- 交易A → 交易B和交易C（交易A的输出被交易B和交易C引用）。
- 交易B → 交易D和交易E（交易B的输出被交易D和交易E引用）。
- 交易C → 交易F（交易C的输出被交易F引用）。

这种结构可以用以下图示表示：

```
        A
       / \
      B   C
     / \   \
    D   E   F
```

在这个例子中：
- 交易A的“扇出”是2（因为它被2笔后续交易引用）。
- 交易B的“扇出”是2。
- 交易C的“扇出”是1。

---

### 3. **扇出的意义**
“扇出”在比特币网络中有以下重要意义：

#### （1）**交易的复杂性**
- 高“扇出”意味着一笔交易可能被多个后续交易依赖，这增加了交易验证的复杂性。
- 例如，验证交易D时，需要验证交易B，而交易B又依赖于交易A。因此，验证交易D需要追溯到交易A。

#### （2）**隐私保护**
- 高“扇出”可以增加隐私保护，因为交易之间的依赖关系使得追踪资金流向更加困难。
- 例如，通过将一笔交易拆分成多个输出，并将这些输出发送到不同的地址，可以隐藏资金的最终流向。

#### （3）**网络效率**
- “扇出”结构使得比特币网络能够高效地处理大量交易，而不需要存储完整的交易历史。
- 通过梅克尔树（Merkle Tree），节点可以验证交易的存在，而无需存储所有依赖的交易。

---

### 4. **扇出与隐私**
尽管“扇出”可以增加隐私保护，但它也可能带来一些隐私风险。例如：
- **多输入交易**：如果一笔交易包含多个输入（来自多个之前的交易），这些输入可能被链接到同一个所有者，从而暴露用户的隐私。
- **隐私保护措施**：为了进一步保护隐私，比特币建议用户为每笔交易使用新的地址，并尽量避免多输入交易。

---

### 5. **总结**
“扇出”描述了比特币交易的依赖关系，即一笔交易可能被多个后续交易引用，而这些后续交易又可能被更多的交易引用。这种结构类似于树形结构的分支，增加了交易验证的复杂性，同时也为隐私保护和网络效率提供了支持。理解“扇出”有助于更好地理解比特币网络中交易的传播和验证机制。




# 原文翻译

**比特币：一种点对点的电子现金系统**

**中本聪**  
satoshin@gmx.com  
www.bitcoin.org  

## 摘要  

一个纯粹的点对点电子现金系统将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名提供了部分解决方案，但如果仍然需要一个可信的第三方来防止双重支付，那么主要的好处就会丧失。我们提出了一种使用点对点网络解决双重支付问题的方案。网络通过将交易哈希并将其嵌入到一个基于哈希的“工作量证明”链中来对交易进行时间戳标记，形成一个不可更改的记录，除非重新完成工作量证明。最长的链不仅证明了见证事件的顺序，还证明了它来自最大的CPU算力池。只要大多数CPU算力由不合作攻击网络的节点控制，它们就会生成最长的链并超越攻击者。网络本身几乎不需要结构。消息以尽力而为的方式广播，节点可以随意离开和重新加入网络，接受最长的工作量证明链作为他们离开期间发生事件的证明。



## 1. 引言  

互联网上的商业活动几乎完全依赖于金融机构作为可信的第三方来处理电子支付。尽管这种系统对大多数交易来说运行良好，但它仍然存在基于信任模型的固有弱点。完全不可逆的交易实际上是不存在的，因为金融机构无法避免调解争议。调解成本会增加交易成本，限制了最小实际交易金额，并切断了小额偶发交易的可能性。此外，由于无法进行不可逆支付，非可逆服务的支付能力也会丧失。由于存在逆转的可能性，信任的需求会扩散。商家必须对客户保持警惕，向他们索要比其他情况下更多的信息。一定比例的欺诈被视为不可避免的。这些成本和支付不确定性可以通过使用实物货币在场交易来避免，但目前还没有一种机制可以在没有可信方的情况下通过通信渠道进行支付。  

我们需要一种基于密码学证明而非信任的电子支付系统，允许任意两个愿意的参与者直接进行交易，而无需信任第三方。计算上不可逆的交易将保护卖家免受欺诈，而常规的托管机制可以轻松实现以保护买家。在本文中，我们提出了一个使用点对点分布式时间戳服务器生成交易时间顺序的计算证明来解决双重支付问题的方案。只要诚实节点集体控制的CPU算力超过任何合作攻击节点的算力，系统就是安全的。



## 2. 交易  

我们定义一个电子货币为一个数字签名链。每个所有者通过数字签名前一次交易的哈希值和下一个所有者的公钥，并将这些添加到货币的末尾，从而将货币转移给下一个所有者。收款人可以通过验证签名来验证所有权链。  

当然，问题在于收款人无法验证其中一个所有者是否没有对该货币进行双重支付。一个常见的解决方案是引入一个可信的中央权威机构或造币厂，检查每一笔交易是否出现双重支付。每次交易后，货币必须返回造币厂以发行新货币，只有直接从造币厂发行的货币才被认为是可信的，不会被双重支付。这种解决方案的问题在于，整个货币系统的命运取决于运营造币厂的公司，每一笔交易都必须经过他们，就像银行一样。  

我们需要一种方法让收款人知道之前的拥有者没有签署任何更早的交易。对于我们的目的来说，最早的交易是最重要的，所以我们不关心之后的双重支付尝试。确认没有交易的唯一方法是知晓所有交易。在基于造币厂的模型中，造币厂知晓所有交易并决定哪一个先到达。为了在没有可信方的情况下实现这一点，交易必须公开宣布[^1^]，我们需要一个系统让参与者就它们接收的顺序达成一致的历史记录。收款人需要证明在每次交易时，大多数节点都同意它是第一个收到的。



## 3. 时间戳服务器  

我们提出的解决方案从时间戳服务器开始。时间戳服务器通过对要时间戳标记的一组数据进行哈希处理，并广泛发布该哈希值（例如在报纸或Usenet帖子中）[2-5]。时间戳证明了数据必须在当时已经存在，才能被哈希处理。每个时间戳都包含前一个时间戳的哈希值，形成一个链，每个额外的时间戳都加强了之前的时间戳。


## 4. 工作量证明

为了在点对点的基础上实现分布式时间戳服务器，我们需要使用类似于Adam Back的Hashcash的工作量证明系统[^6^]，而不是报纸或Usenet帖子。工作量证明涉及扫描一个值，当对其进行哈希处理时（例如使用SHA-256），哈希值以一定数量的零位开头。所需的零位数量越多，平均工作量呈指数增长，而验证只需执行一次哈希。

在我们的时间戳网络中，工作量证明通过在区块中增加一个随机数（nonce），直到找到一个使区块哈希值满足所需零位数量的值[^6^]。一旦CPU努力被投入以满足工作量证明，该区块就无法被更改，除非重新完成工作。随着后续区块被链接到该区块之后，更改该区块的工作量将包括重新完成该区块以及其后所有区块的工作量。

工作量证明还解决了在多数决策中确定代表权的问题。如果多数决策基于“一个IP地址一票”，那么任何能够分配大量IP地址的人都可以篡改系统。工作量证明本质上是“一个CPU一票”。多数决策由最长的链表示，这条链投入了最多的工作量证明。如果大多数CPU算力由诚实节点控制，那么诚实的链将增长得最快，并超越任何竞争链。攻击者若想修改一个过去的区块，他必须重新完成该区块及其后所有区块的工作量证明，并且在诚实节点完成后续工作之前赶上并超越它们。我们稍后会展示，随着后续区块的增加，攻击者赶上的概率会呈指数级下降[^8^]。

为了应对硬件速度的提高以及运行节点的兴趣随时间的变化，工作量证明的难度由一个移动平均值决定，目标是平均每小时产生一定数量的区块。如果区块生成速度过快，难度就会增加[^6^]。



## 5. 网络

运行网络的步骤如下：

1. 新的交易被广播到所有节点。  
2. 每个节点将新的交易收集到一个区块中。  
3. 每个节点为其区块寻找一个困难的工作量证明。  
4. 当一个节点找到一个工作量证明时，它将该区块广播到所有节点。  
5. 节点只有在区块中的所有交易都是有效且未被消费的情况下才会接受该区块。  
6. 节点通过在链中创建下一个区块，并使用已接受区块的哈希值作为前一个哈希值，来表达对区块的接受。  

节点始终认为最长的链是正确的，并将继续努力扩展它。如果两个节点同时广播下一个区块的不同版本，一些节点可能会先收到其中一个。在这种情况下，它们会先处理第一个收到的版本，但会保存另一个分支，以防它变得更长。当找到下一个工作量证明时，分支之间的竞争将被打破，其中一个分支变得更长；那些在另一个分支上工作的节点将切换到更长的分支。

新的交易广播并不一定需要到达所有节点。只要它们到达许多节点，它们就会很快被包含在一个区块中。区块广播对丢失消息也是容忍的。如果一个节点没有收到一个区块，它会在收到下一个区块并意识到自己错过了一个区块时请求它。



## 6. 激励机制

按照惯例，区块中的第一笔交易是一个特殊的交易，它产生一个新的货币单位，归该区块的创建者所有。这为节点支持网络提供了激励，并提供了一种将货币初始分配到流通中的方式，因为没有中央机构来发行货币。稳定地增加一定数量的新货币，类似于黄金矿工投入资源将黄金添加到流通中。在我们的情况下，投入的是CPU时间和电力。

激励机制也可以通过交易费用来资助。如果一笔交易的输出值小于其输入值，差额就是交易费用，这笔费用将被添加到包含该交易的区块的激励价值中。一旦一定数量的货币进入流通，激励机制可以完全过渡到交易费用，并且完全无通胀。

激励机制可能有助于鼓励节点保持诚实。如果一个贪婪的攻击者能够聚集比所有诚实节点更多的CPU算力，他将不得不在两种选择之间做出决定：要么通过窃取回他的支付来欺诈他人，要么通过生成新的货币单位来获利。他应该会发现，按照规则行事会更有利可图，因为规则会使他获得比其他所有人加起来更多的新货币，而不是破坏系统以及他自己的财富的有效性。


## 7. 回收磁盘空间

一旦某笔交易的最新状态被足够多的区块覆盖，那么在这之前的已消费交易就可以被丢弃以节省磁盘空间。为了在不破坏区块哈希的情况下实现这一点，交易被组织成一棵**梅克尔树（Merkle Tree）**[^7^][^2^][^5^]，只有树的根哈希值被包含在区块的哈希中。这样，旧的区块可以通过截断树的分支进行压缩，而内部哈希值则无需存储。

一个没有交易的区块头大约为80字节。假设每10分钟生成一个区块，那么每年的存储需求为：

$$
80 \text{字节} \times 6 \times 24 \times 365 = 4.2 \text{MB}
$$

截至2008年，计算机系统通常配备2GB的内存，而根据摩尔定律，内存容量每年增长约1.2GB[^9^]。因此，即使区块头需要保留在内存中，存储也根本不是问题。



## 8. 简化支付验证

即使不运行完整的网络节点，也可以验证支付。用户只需要保留最长工作量证明链的区块头副本，他可以通过查询网络节点来确认自己已经拥有了最长的链，并获取将交易链接到其被时间戳标记的区块的梅克尔分支。他无法自行验证交易，但通过将其链接到链中的一个位置，他可以看到网络节点已经接受了这笔交易，而后续添加的区块进一步确认了网络对这笔交易的接受。

只要诚实节点控制着网络，这种验证方法就是可靠的，但如果网络被攻击者控制，它就更容易受到攻击。尽管网络节点可以自行验证交易，但简化的方法可能会被攻击者制造的虚假交易欺骗，只要攻击者能够持续控制网络。一种防范策略是，当网络节点检测到无效区块时，向用户发送警报，提示用户的软件下载完整的区块和被警告的交易，以确认不一致之处。频繁接收支付的企业可能仍然希望运行自己的节点，以获得更独立的安全性和更快的验证速度。



## 9. 价值的合并与拆分

尽管可以单独处理每枚货币，但在转账时为每一美分都创建单独的交易是不切实际的。为了允许价值的拆分和合并，交易包含多个输入和输出。通常情况下，交易会有一个来自更大金额的前一笔交易的单一输入，或者将多个较小金额的输入合并起来，最多有两个输出：一个用于支付，另一个将找零（如果有）返回给发送者。

需要注意的是，交易的“扇出”（fan-out）在这里并不是问题。一笔交易依赖于多笔交易，而这些交易又依赖于更多交易，这种结构并不会带来问题。因为从未需要提取一笔交易历史的完整独立副本。



## 10. 隐私

传统银行模式通过限制信息访问权限来实现隐私，只有交易双方和可信的第三方能够看到交易信息。然而，公开宣布所有交易的做法排除了这种方法，但隐私仍然可以通过另一种方式保持：通过保持公钥的匿名性。公众可以看到有人向另一个人发送了一笔金额，但没有信息将交易与任何人联系起来。这类似于证券交易所发布的信息，其中个人交易的时间和金额（“行情”）被公开，但不透露交易双方的身份。

作为一种额外的防火墙，每笔交易都应该使用一个新的密钥对，以防止它们被链接到同一个所有者。然而，在多输入交易中，仍然不可避免地会有一些链接，因为这些输入必然揭示了它们属于同一个所有者。如果一个密钥的所有者身份被暴露，那么链接可能会揭示其他属于同一个所有者的交易。


## 11. 计算

我们考虑一个攻击者试图生成一个比诚实链更快的替代链的场景。即使这得以实现，也不会使系统对任意更改开放，例如凭空创造价值或窃取从未属于攻击者的资金。节点不会接受无效交易作为支付，诚实节点也永远不会接受包含这些交易的区块。攻击者只能尝试更改他自己的某笔交易，以收回他最近花费的资金。

诚实链与攻击者链之间的竞争可以被描述为一个**二项随机游走（Binomial Random Walk）**。成功事件是诚实链通过一个区块的扩展而增加其领先优势 +1，而失败事件是攻击者链通过一个区块的扩展而减少差距 -1。

攻击者从给定的落后距离追上来的概率类似于**赌徒破产问题（Gambler's Ruin problem）**。假设一个拥有无限信用额度的赌徒从落后开始，并进行潜在的无限次试验以试图达到收支平衡。我们可以计算他最终达到收支平衡的概率，或者攻击者最终追上诚实链的概率如下[^8^]：

设：
- $p$ = 诚实节点找到下一个区块的概率  
- $q$ = 攻击者找到下一个区块的概率  
- $q_z$ = 攻击者从落后 $z$ 个区块追上的概率

则：
$$
q_z =
\begin{cases}
1 & \text{如果 } p \leq q \\
\left(\frac{q}{p}\right)^z & \text{如果 } p > q
\end{cases}
$$

假设 $p > q$，随着攻击者需要追上的区块数量增加，概率会呈指数级下降。如果攻击者不能在早期幸运地向前冲刺，那么随着他进一步落后，他的机会将变得微乎其微。

我们现在考虑接收一笔新交易的接收者需要等待多长时间，才能确信发送者无法更改这笔交易。我们假设发送者是一个攻击者，他希望让接收者相信他支付了一段时间，然后试图将其切换为支付给自己。接收者会在那一刻收到警报，但发送者希望为时已晚。

接收者生成一个新的密钥对，并在签名前不久将公钥交给发送者。这可以防止发送者通过持续工作提前准备一个区块链，直到他足够幸运地领先足够多，然后在那一刻执行交易。一旦交易发送，不诚实的发送者开始秘密地在一个包含他交易替代版本的并行链上工作。

接收者等待这笔交易被添加到一个区块中，并且在其后链接了 $z$ 个区块。他不知道攻击者取得了多大的进展，但假设诚实区块以每个区块的平均预期时间生成，攻击者的潜在进展将是一个泊松分布，其期望值为：

$$
\lambda = z \cdot \frac{q}{p}
$$

为了计算攻击者现在仍然可能追上的概率，我们将泊松密度乘以他可能取得的每种进展程度的概率：

$$
\sum_{k=0}^{\infty} \frac{\lambda^k e^{-\lambda}}{k!} \cdot
\begin{cases}
\left(\frac{q}{p}\right)^{z-k} & \text{如果 } k \leq z \\
1 & \text{如果 } k > z
\end{cases}
$$

重新排列公式，以避免求和无穷尾部的分布：

$$
1 - \sum_{k=0}^{z} \frac{\lambda^k e^{-\lambda}}{k!} \left(1 - \left(\frac{q}{p}\right)^{z-k}\right)
$$

转换为C语言代码：

```c
#include <math.h>
double AttackerSuccessProbability(double q, int z) {
    double p = 1.0 - q;
    double lambda = z * (q / p);
    double sum = 1.0;
    int i, k;
    for (k = 0; k <= z; k++) {
        double poisson = exp(-lambda);
        for (i = 1; i <= k; i++) poisson *= lambda / i;
        sum -= poisson * (1 - pow(q / p, z - k));
    }
    return sum;
}
```

运行一些结果，我们可以看到概率随着 $z$ 的增加呈指数级下降：

| $q$ | $z$ | 概率 $P$ |
|-----|-----|----------|
| 0.1 | 0   | 1.0000000 |
| 0.1 | 1   | 0.2045873 |
| 0.1 | 2   | 0.0509779 |
| 0.1 | 3   | 0.0131722 |
| 0.1 | 4   | 0.0034552 |
| 0.1 | 5   | 0.0009137 |
| 0.1 | 6   | 0.0002428 |
| 0.1 | 7   | 0.0000647 |
| 0.1 | 8   | 0.0000173 |
| 0.1 | 9   | 0.0000046 |
| 0.1 | 10  | 0.0000012 |

| $q$ | $z$ | 概率 $P$ |
|-----|-----|----------|
| 0.3 | 0   | 1.0000000 |
| 0.3 | 5   | 0.1773523 |
| 0.3 | 10  | 0.0416605 |
| 0.3 | 15  | 0.0101008 |
| 0.3 | 20  | 0.0024804 |
| 0.3 | 25  | 0.0006132 |
| 0.3 | 30  | 0.0001522 |
| 0.3 | 35  | 0.0000379 |
| 0.3 | 40  | 0.0000095 |
| 0.3 | 45  | 0.0000024 |
| 0.3 | 50  | 0.0000006 |

求解 $P$ 小于 0.1% 的情况：

| $q$ | $z$ |
|-----|-----|
| 0.10| 5   |
| 0.15| 8   |
| 0.20| 11  |
| 0.25| 15  |
| 0.30| 24  |
| 0.35| 41  |
| 0.40| 89  |
| 0.45| 340 |


## 12. 结论

我们提出了一个**不依赖信任的电子交易系统**。我们从通常的框架开始，即由数字签名构成的货币，它提供了对所有权的强有力控制，但如果没有防止双重支付的方法，这个框架是不完整的。为了解决这个问题，我们提出了一个使用**工作量证明（Proof-of-Work）**的点对点网络，记录交易的公共历史记录。如果诚实节点控制了大多数CPU算力，那么攻击者改变历史记录将变得在计算上极为不切实际。网络以其无结构的简洁性表现出强大的健壮性。节点同时工作，几乎不需要协调。它们不需要被识别，因为消息不是路由到特定位置，只需要尽力而为地传递。节点可以随意离开和重新加入网络，并接受工作量证明链作为它们离开期间发生事件的证明。它们通过CPU算力进行投票，通过扩展有效区块来表达对区块的接受，并通过拒绝在无效区块上工作来拒绝它们。任何必要的规则和激励都可以通过这种共识机制来执行。



这篇论文的核心思想是通过去中心化的网络和密码学技术，实现一种无需信任第三方的电子支付系统，同时解决了双重支付问题。比特币网络的运行机制、激励机制和安全性都基于这种设计。
