---
layout: mypost
title: k061 GSCore, Efficient Radiance Field Rendering via Architectural Support for 3D Gaussian Splatting
categories: [3DGS]
---

# 论文重点与难点

## 1 **研究背景与动机**

- **背景**：3D Gaussian Splatting 是一种基于高斯分布的体积渲染技术，能够高效地生成高质量的3D场景视图，但其在移动设备和边缘计算平台上的实时渲染性能受限于计算资源。

- **动机**：现有的移动GPU在处理3D Gaussian Splatting时性能不足，难以满足实时渲染需求。因此，作者提出了一种专用的硬件加速单元 **GSCore**，旨在通过算法优化和硬件支持提升渲染效率。

## 2 **GSCore 的核心贡献**

- **算法优化**：

  - **高斯形状感知的交集测试（Gaussian Shape-Aware Intersection Test）**：通过使用定向包围盒（OBB）代替传统的轴对齐包围盒（AABB），减少高斯与像素的误判，降低后续排序和光栅化阶段的计算量。

  - **层次化排序（Hierarchical Sorting）**：采用两阶段排序策略，先进行近似排序，再根据需要进行精确排序，减少了排序开销。

  - **子瓦片跳过（Subtile Skipping）**：通过将瓦片细分为更小的子瓦片，并在预处理阶段生成位图，跳过对像素颜色无贡献的高斯分布的计算，减少无效计算。

- **硬件设计**：

  - **GSCore 架构**：包含三个主要模块：Culling and Conversion Unit（CCU）、Gaussian Sorting Unit（GSU）和 Volume Rendering Unit（VRU）。CCU 负责高斯分布的裁剪和特征转换；GSU 负责层次化排序；VRU 负责光栅化渲染。

  - **专用硬件单元**：如 Bitonic Sorting Unit 和 Volume Rendering Core，针对高斯分布的排序和体积渲染进行了优化。

## 3 **性能评估**

- **性能提升**：

  - GSCore 在多个真实世界和合成场景中，平均速度比移动GPU快 **15.86倍**，同时在面积和功耗上显著降低。

  - 通过算法优化和硬件支持，GSCore 在保持图像质量的同时，显著提高了计算效率。

- **能效**：

  - GSCore 的功耗仅为 **0.87W**，在28nm工艺下面积为 **3.95mm²**，相比移动GPU，能效提升了 **15.50倍**。

## 4 **难点与解决方案**

- **难点 1：高斯分布与像素的误判**

  - **解决方案**：通过高斯形状感知的交集测试，减少误判，降低不必要的计算。

- **难点 2：排序开销大**

  - **解决方案**：采用层次化排序策略，减少排序开销，并通过与光栅化阶段的重叠执行隐藏排序延迟。

- **难点 3：无效计算**

  - **解决方案**：通过子瓦片跳过机制，减少对像素颜色无贡献的高斯分布的计算。

## 5 **结论**

- GSCore 通过算法优化和硬件支持，显著提升了3D Gaussian Splatting 的渲染效率，使其能够在移动设备和边缘计算平台上实现实时渲染，同时保持高质量的图像输出。

# 论文详细讲解

GSCore: Efficient Radiance Field Rendering via Architectural Support for 3D Gaussian Splatting

## 1 **研究背景**

3D Gaussian Splatting 是一种基于高斯分布的体积渲染技术，能够高效地生成高质量的3D场景视图，广泛应用于虚拟现实、移动计算等领域。然而，现有的移动GPU在处理3D Gaussian Splatting时性能不足，难以满足实时渲染需求。因此，本文提出了一种专用的硬件加速单元 **GSCore**，旨在通过算法优化和硬件支持提升渲染效率。

## 2 **研究动机**

尽管3D Gaussian Splatting在渲染质量和性能上优于传统方法，但在移动设备和边缘计算平台上实现实时渲染仍面临挑战。分析表明，高斯排序和光栅化是渲染时间的主要贡献者，且现有的交集测试方法存在大量误判，导致不必要的计算。因此，本文提出了一系列优化技术，包括高斯形状感知的交集测试、层次化排序和子瓦片跳过，以减少无效计算并提升性能。

## 3 **GSCore 的设计与优化**

### 3.1 高斯形状感知的交集测试

在预处理阶段，传统的轴对齐包围盒（AABB）交集测试会导致大量误判，增加后续排序和光栅化的计算量。为此，本文提出使用定向包围盒（OBB）进行更精确的交集测试。OBB能够更好地适应高斯分布的各向异性，减少误判。具体实现中，仅在满足特定条件（如高斯的长宽比超过阈值）时使用OBB，以平衡计算开销和精度。

### 3.2 层次化排序

层次化排序是一种两阶段排序策略：

`1.` **近似排序**：将高斯分布按深度分为多个块（chunk），块内高斯分布的顺序不严格排序，但块之间的顺序保证深度递增。

`2.` **精确排序**：在光栅化时，仅对当前需要处理的块进行精确排序。如果由于早期终止（early termination）跳过某些块，则无需对其进行排序。这种策略减少了排序开销，并通过与光栅化阶段的重叠执行隐藏排序延迟。

### 3.3 子瓦片跳过

在光栅化阶段，大量高斯分布对像素颜色的贡献微乎其微，导致无效计算。为此，本文提出将瓦片细分为更小的子瓦片，并在预处理阶段生成位图，标记高斯分布是否与子瓦片相交。在光栅化时，跳过对像素颜色无贡献的高斯分布的计算，从而减少无效计算。

## 4 **GSCore 架构设计**

GSCore 包含三个主要模块：

`1.` **Culling and Conversion Unit (CCU)**：负责高斯分布的裁剪和特征转换，包括高斯形状感知的交集测试。

`2.` **Gaussian Sorting Unit (GSU)**：负责层次化排序，包括近似排序和精确排序。

`3.` **Volume Rendering Unit (VRU)**：负责光栅化渲染，支持子瓦片跳过机制。

### 4.1 CCU 设计

CCU 包含多个OBB交集测试单元，用于检测高斯分布与瓦片的交集，并生成子瓦片位图。通过减少误判，CCU显著降低了后续模块的计算量。

### 4.2 GSU 设计

GSU 采用两阶段排序策略：

- **近似排序**：使用快速排序算法（Quick Sort）将高斯分布分为多个块。

- **精确排序**：使用比特排序算法（Bitonic Sort）对当前需要处理的块进行精确排序。GSU的设计平衡了排序效率和硬件开销。

### 4.3 VRU 设计

VRU 包含多个体积渲染核心（VR Core），每个核心负责渲染2×2像素。通过子瓦片跳过机制，VRU能够跳过对像素颜色无贡献的高斯分布的计算，从而减少无效计算。此外，VRU采用了像素旋转流水线设计，避免了因等待计算结果而导致的流水线停顿。

## 5 **性能评估**

### 5.1 性能提升

GSCore 在多个真实世界和合成场景中表现出显著的性能提升：

- 平均速度比移动GPU快 **15.86倍**。

- 在不同分辨率的场景中，GSCore均能实现实时渲染。

### 5.2 能效分析

GSCore 的功耗仅为 **0.87W**，在28nm工艺下面积为 **3.95mm²**，相比移动GPU，能效提升了 **15.50倍**。通过减少无效计算和优化内存访问，GSCore在保持图像质量的同时显著降低了功耗。

### 5.3 图像质量

尽管采用了多种优化技术，GSCore并未牺牲图像质量。与原始实现相比，GSCore在PSNR和LPIPS指标上均表现出几乎相同的图像质量。

## 6 **实验结果**

实验结果表明，GSCore在不同场景下的性能提升主要来源于以下三个方面：

`1.` **高斯形状感知的交集测试**：减少了高斯与瓦片的误判，降低了排序和光栅化的计算量。

`2.` **层次化排序**：减少了排序开销，并通过与光栅化阶段的重叠执行隐藏排序延迟。

`3.` **子瓦片跳过**：减少了光栅化阶段的无效计算。

## 7 **结论**

GSCore通过算法优化和硬件支持，显著提升了3D Gaussian Splatting的渲染效率，使其能够在移动设备和边缘计算平台上实现实时渲染，同时保持高质量的图像输出。通过减少无效计算和优化内存访问，GSCore在面积和功耗上均表现出显著的效率提升。

# 论文方法部分详细讲解

## 1 **3D Gaussian Splatting 渲染流程分析**

3D Gaussian Splatting 的渲染流程主要包括以下四个步骤：

`1.` **视锥裁剪（Frustum Culling）**：移除从当前视点不可见的高斯分布。

`2.` **特征计算（Feature Computation）**：计算高斯分布的投影特征，包括2D均值、协方差矩阵以及颜色。

`3.` **高斯排序（Gaussian Sorting）**：根据深度对高斯分布进行排序，以支持体积渲染中的前后顺序累积。

`4.` **光栅化（Volume Rendering）**：通过体积渲染方程计算像素颜色，涉及α值计算、早期终止和颜色累积。

分析表明，**高斯排序**和**光栅化**是渲染时间的主要瓶颈，分别占据了约80%的渲染时间。

## 2 **优化方法**

为了解决上述瓶颈，论文提出了三种优化技术：高斯形状感知的交集测试、层次化排序和子瓦片跳过。

### 2.1 高斯形状感知的交集测试（Gaussian Shape-Aware Intersection Test）

传统的轴对齐包围盒（AABB）交集测试会导致大量误判，增加不必要的计算。论文提出使用定向包围盒（OBB）进行更精确的交集测试：

- **AABB vs. OBB**：AABB计算简单但误判率高，而OBB能够更好地拟合高斯分布的形状，减少误判。

- **选择性使用OBB**：仅当高斯分布的长宽比超过阈值（如2）时，才使用OBB进行交集测试，以平衡计算开销和精度。

**优化效果**：减少高斯与瓦片的误判，降低排序和光栅化的计算量。

### 2.2 层次化排序（Hierarchical Sorting）

层次化排序是一种两阶段排序策略，旨在减少排序开销：

`1.` **近似排序（Approximate Sorting）**：将高斯分布按深度分为多个块（chunk），块内高斯分布的顺序不严格排序，但块之间的顺序保证深度递增。

`2.` **精确排序（Precise Sorting）**：在光栅化时，仅对当前需要处理的块进行精确排序。如果由于早期终止跳过某些块，则无需对其进行排序。

**优化效果**：

- 减少排序开销。

- 通过与光栅化阶段的重叠执行隐藏排序延迟。

### 2.3 子瓦片跳过（Subtile Skipping）

在光栅化阶段，大量高斯分布对像素颜色的贡献微乎其微，导致无效计算。论文提出将瓦片细分为更小的子瓦片，并在预处理阶段生成位图，标记高斯分布是否与子瓦片相交：

- **子瓦片位图**：每个高斯分布分配一个位图，指示其是否与子瓦片相交。

- **跳过无效计算**：在光栅化时，跳过对像素颜色无贡献的高斯分布的计算。

**优化效果**：减少光栅化阶段的无效计算，提升渲染效率。

## 3 **GSCore 硬件架构设计**

为了进一步提升性能，论文设计了专用硬件加速单元 **GSCore**，其架构包括三个主要模块：

`1.` **裁剪与转换单元（Culling and Conversion Unit, CCU）**：

   - 负责高斯分布的视锥裁剪和特征计算。

   - 实现高斯形状感知的交集测试，生成子瓦片位图。

`2.` **高斯排序单元（Gaussian Sorting Unit, GSU）**：

   - 实现层次化排序，包括近似排序和精确排序。

   - 使用快速排序（Quick Sort）和比特排序（Bitonic Sort）算法优化排序效率。

`3.` **体积渲染单元（Volume Rendering Unit, VRU）**：

   - 负责光栅化渲染，支持子瓦片跳过机制。

   - 采用像素旋转流水线设计，避免因等待计算结果而导致的流水线停顿。

**硬件设计的关键点**：

- **专用硬件单元**：如Bitonic Sorting Unit和Volume Rendering Core，针对高斯分布的排序和体积渲染进行了优化。

- **面积与功耗优化**：通过减少无效计算和优化内存访问，GSCore在面积和功耗上表现出显著的效率提升。

## 4 **优化方法的协同作用**

论文提出的三种优化技术相互协同，共同提升渲染效率：

- **高斯形状感知的交集测试**减少了高斯与瓦片的误判，降低了排序和光栅化的计算量。

- **层次化排序**减少了排序开销，并通过与光栅化阶段的重叠执行隐藏排序延迟。

- **子瓦片跳过**减少了光栅化阶段的无效计算，进一步提升了渲染效率。

通过算法优化和硬件支持，GSCore在保持图像质量的同时显著提高了3D Gaussian Splatting的渲染效率，使其能够在移动设备和边缘计算平台上实现实时渲染。