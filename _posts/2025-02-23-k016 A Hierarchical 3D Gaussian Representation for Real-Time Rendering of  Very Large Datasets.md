---
layout: mypost
title: k016 A Hierarchical 3D Gaussian Representation for Real-Time Rendering of Very Large Datasets
categories: [3DGS, 大场景]
---


# 链接

- [arxiv](https://arxiv.org/abs/2406.12080)
- [GitHub](https://github.com/graphdeco-inria/hierarchical-3d-gaussians)

Arxiv时间：Mon, 17 Jun 2024 20:40:18 UTC (47,070 KB)

# 重点难点分析

这篇论文《A Hierarchical 3D Gaussian Representation for Real-Time Rendering of Very Large Datasets》提出了一种基于层次化3D高斯表示的方法，用于实时渲染非常大的数据集。它解决了传统方法在处理大规模场景时资源受限的问题。以下是这篇论文的重点和难点：



## 论文重点
1. **研究目标与动机**：
   - 现有的3D高斯渲染方法（如3D Gaussian Splatting）虽然在视觉质量和实时渲染方面表现出色，但受限于资源（如内存和计算能力），无法处理大规模场景。
   - 论文提出了一种分而治之的策略，通过将场景划分为多个“块”（chunks），并为每个块构建独立的层次化3D高斯表示，从而实现大规模场景的高效训练和实时渲染。

2. **层次化3D高斯表示**：
   - **层次化结构**：通过构建一个基于3D高斯的层次化树结构，每个节点（包括叶节点和内部节点）都是一个3D高斯体元，能够高效地表示场景的细节和概要。
   - **细节层次（LOD）**：通过选择不同层次的节点进行渲染，实现了根据视点距离自动调整细节层次的功能，从而在保证视觉质量的同时显著降低计算和内存开销。

3. **分块训练与优化**：
   - **分块策略**：将大规模场景划分为多个独立的块，并对每个块进行独立的优化和层次化处理。这种方法允许并行处理，大大加快了大规模场景的训练速度。
   - **优化改进**：针对大规模场景数据稀疏、覆盖不均匀等问题，论文提出了一系列优化策略，如深度监督和曝光补偿，以提高渲染质量。

4. **实时渲染与性能**：
   - 通过层次化LOD机制，论文实现了大规模场景的实时渲染，能够在消费级硬件上流畅地导航和交互。
   - 在多个大规模数据集上的实验表明，该方法能够在保持较高视觉质量的同时，显著降低渲染所需的资源消耗。

5. **开源与数据集**：
   - 论文计划开源代码和数据集，这将极大地促进该领域的研究和应用。



## 论文难点
1. **层次化结构的构建与优化**：
   - **难点**：如何高效地构建层次化3D高斯树结构，并在不同层次之间实现平滑的过渡和优化。
   - **解决方案**：论文提出了一种基于轴对齐包围盒（AABB）的层次化构建方法，并通过优化内部节点的属性（如位置、协方差、颜色等）来提高视觉质量。

2. **大规模场景的分块训练**：
   - **难点**：如何在分块训练中保持场景的一致性，并处理块与块之间的边界问题。
   - **解决方案**：论文通过引入粗略初始化和块间合并步骤，确保了场景的整体一致性和细节的准确性。

3. **稀疏数据的优化**：
   - **难点**：大规模场景的数据通常稀疏且覆盖不均匀，这可能导致优化过程中的细节丢失和视觉伪影。
   - **解决方案**：论文引入了深度监督和曝光补偿等正则化策略，以增强优化过程的鲁棒性。

4. **实时渲染的性能优化**：
   - **难点**：如何在实时渲染中高效地选择和切换不同层次的细节，同时保持视觉质量。
   - **解决方案**：论文通过动态选择层次化树的切点（cut point）和插值策略，实现了高效的LOD渲染。

5. **数据采集与预处理**：
   - **难点**：大规模场景的数据采集通常包含大量噪声（如移动物体、曝光变化等），这会影响最终的渲染质量。
   - **解决方案**：论文通过深度学习方法（如Mask R-CNN）去除移动物体，并优化曝光补偿，以提高数据质量。



## 总结
这篇论文的核心贡献在于提出了一种层次化3D高斯表示方法，能够高效地处理和渲染大规模场景。它通过分块训练、层次化LOD机制和优化策略，解决了传统方法在资源受限情况下的瓶颈问题。论文不仅在技术上具有创新性，还通过开源代码和数据集为该领域的研究提供了重要支持。


# 详细讲解

这篇论文《A Hierarchical 3D Gaussian Representation for Real-Time Rendering of Very Large Datasets》提出了一种基于层次化3D高斯表示的方法，用于实时渲染非常大的数据集。它解决了传统方法在处理大规模场景时资源受限的问题，同时保持了较高的视觉质量和实时性。以下是对论文的详细讲解：



## 1. 研究背景与动机
### 1.1 研究背景
- **新型视图合成（Novel View Synthesis, NVS）**：近年来，随着神经渲染技术的发展，如神经辐射场（NeRF）和3D高斯渲染（3D Gaussian Splatting），新型视图合成技术取得了显著进展。这些技术能够在给定一组输入图像的情况下，合成出从未见过的视角图像。
- **3D高斯渲染（3DGS）**：3DGS是一种基于显式几何表示的方法，结合了高视觉质量、快速训练和实时渲染的优点。然而，传统3DGS方法在处理大规模场景时会受到资源限制，例如内存和计算能力不足。

### 1.2 研究动机
- **大规模场景的挑战**：现有的3D高斯渲染方法在处理大规模场景时会面临资源瓶颈，导致无法高效地表示和渲染大规模场景。
- **分而治之的策略**：为了解决这一问题，论文提出了一种分而治之的方法，将大规模场景划分为多个小块（chunks），并为每个块构建独立的层次化3D高斯表示。这种方法不仅允许并行处理，还通过层次化细节层次（LOD）机制实现了高效的渲染。



## 2. 研究方法
### 2.1 层次化3D高斯表示
- **层次化结构**：论文提出了一种基于树的层次化结构，每个节点（包括叶节点和内部节点）都是一个3D高斯体元。叶节点来自原始3DGS优化，而内部节点通过合并子节点的高斯分布生成。
- **合并策略**：为了合并多个3D高斯体元，论文使用了最小化Kullback-Leibler散度的方法，通过加权平均计算合并后的均值和协方差。
- **细节层次（LOD）**：通过选择不同层次的节点进行渲染，实现了根据视点距离自动调整细节层次的功能。这不仅降低了计算和内存开销，还保持了较高的视觉质量。

### 2.2 分块训练与优化
- **分块策略**：将大规模场景划分为多个独立的块，并对每个块进行独立的优化和层次化处理。这种方法允许并行处理，大大加快了大规模场景的训练速度。
- **优化改进**：针对大规模场景数据稀疏、覆盖不均匀等问题，论文提出了一系列优化策略，如深度监督和曝光补偿，以提高渲染质量。
- **深度监督**：使用深度学习方法（如DPT）预测单目深度，并将其与SfM点的深度进行对齐，以增强优化过程的鲁棒性。
- **曝光补偿**：通过优化每张图像的曝光补偿矩阵，解决了由于曝光变化导致的渲染问题。

### 2.3 实时渲染与性能优化
- **层次化LOD机制**：通过动态选择层次化树的切点（cut point）和插值策略，实现了高效的LOD渲染。这使得在实时渲染中可以根据视点距离自动调整细节层次。
- **性能优化**：论文通过减少每帧渲染的高斯体元数量，显著降低了内存和计算开销。例如，在大规模场景中，优化后的层次化方法可以将每帧渲染的高斯体元数量减少到原始方法的10%以下。



## 3. 实验与结果
### 3.1 数据集
- **数据集来源**：论文使用了多个大规模数据集，包括作者自己采集的数据集（如SmallCity、BigCity、Campus）和Wayve提供的数据集。这些数据集覆盖了从几百米到几公里的范围，包含数千到数万张图像。
- **采集设备**：使用了低成本的GoPro相机，通过自行车头盔或车辆进行采集。

### 3.2 实验结果
- **视觉质量**：论文通过与现有方法（如Mip-NeRF、Instant-NGP、F2-NeRF等）的对比，展示了其在大规模场景上的优势。在视觉质量方面，论文方法在保持较高PSNR（峰值信噪比）和SSIM（结构相似性）的同时，显著降低了LPIPS（感知损失）。
- **实时性**：论文实现了大规模场景的实时渲染，能够在消费级硬件上流畅地导航和交互。例如，在BigCity数据集上，论文方法可以实现30+ FPS的实时渲染。
- **资源消耗**：通过层次化LOD机制，论文显著降低了每帧渲染的高斯体元数量和内存占用。例如，在BigCity数据集上，优化后的层次化方法将每帧渲染的高斯体元数量减少到原始方法的19%。



## 4. 论文的贡献
- **层次化3D高斯表示**：提出了一种基于层次化树结构的3D高斯表示方法，能够高效地表示和渲染大规模场景。
- **分块训练与优化**：通过分块策略和优化改进，解决了大规模场景数据稀疏和覆盖不均匀的问题。
- **实时渲染**：实现了大规模场景的实时渲染，显著降低了资源消耗，提高了渲染效率。
- **开源与数据集**：论文计划开源代码和数据集，为该领域的研究提供了重要支持。



## 5. 论文的局限性与未来工作
- **数据质量与预处理**：大规模场景的数据通常包含噪声（如移动物体、曝光变化等），这会影响最终的渲染质量。虽然论文提出了一些预处理方法，但仍有改进空间。
- **动态LOD选择**：当前的LOD机制是固定的，未来可以引入动态LOD选择，根据资源预算自动调整细节层次。
- **应用场景扩展**：虽然论文主要关注大规模场景的渲染，但其层次化3D高斯表示方法也可以应用于其他领域，如动画、碰撞检测等。



## 总结
这篇论文提出了一种层次化3D高斯表示方法，能够高效地处理和渲染大规模场景。它通过分块训练、层次化LOD机制和优化策略，解决了传统方法在资源受限情况下的瓶颈问题。论文不仅在技术上具有创新性，还通过开源代码和数据集为该领域的研究提供了重要支持。


# 原文翻译

**一种层次化的三维高斯表示方法，用于大规模数据集的实时渲染**


**伯恩哈德·克尔布（Bernhard Kerbl）**，法国Inria、Université Côte d’Azur，奥地利维也纳工业大学  
**安德烈亚斯·梅勒曼（Andreas Meuleman）**，法国Inria、Université Côte d’Azur  
**乔治奥斯·科普纳斯（Georgios Kopanas）**，法国Inria、Université Côte d’Azur  
**迈克尔·维默（Michael Wimmer）**，奥地利维也纳工业大学  
**亚历山大·兰文（Alexandre Lanvin）**，法国Inria、Université Côte d’Azur  
**乔治·德雷塔基斯（George Drettakis）**，法国Inria、Université Côte d’Azur  

(a) 校准相机  
(b) 划分为块  
(c) 每块层次化生成  
(d) 层次化整合  
(e) 实时渲染（>30 FPS）  

**图1.** 从数千个校准相机开始，覆盖大面积区域，我们将场景划分为块（b）。我们引入了一种三维高斯绘制层次结构，以实现大规模数据的高效渲染，并进一步优化以提升视觉质量（c）。我们整合这些层次结构（d），从而实现非常大规模数据集的实时渲染。请参阅我们的项目页面[home page](https://repo-sam.inria.fr/fungraph/hierarchical-3d-gaussians)以查看大规模场景的实时导航视频。

## 摘要
近年来，新型视图合成取得了重大进展，其中3D高斯绘制（3D Gaussian Splatting, 3DGS）提供了极高的视觉质量、快速训练和实时渲染能力。然而，训练和渲染所需的资源不可避免地限制了能够以高质量表示的场景规模。我们引入了一种3D高斯的层次结构，能够在处理非常大的场景时保持视觉质量，同时提供一种高效的细节层次（Level-of-Detail, LOD）解决方案，用于高效渲染远处内容，并实现有效的层次选择和平滑过渡。我们提出了一种分而治之的方法，允许我们将非常大的场景划分为独立的块进行训练。我们将这些块整合为一个层次结构，可以进一步优化以提高合并到中间节点的高斯分布的视觉质量。大规模场景捕获通常具有稀疏的覆盖，给原始3D高斯绘制训练方法带来了诸多挑战；我们调整并正则化了训练过程以应对这些问题。我们提出了一个完整的解决方案，能够实现实时渲染非常大场景，并且可以适应可用资源，这得益于我们的LOD方法。我们展示了使用简单且廉价的设备捕获的场景结果，这些场景包含多达数万张图像，覆盖轨迹长达数公里，持续时间长达一小时。



## 1 引言
近年来，新型视图合成得到了广泛应用，部分得益于辐射场（radiance fields）的革命性进展 [Tewari et al. 2020]，它提供了前所未有的视觉质量，并且随着最近的改进，允许交互式甚至实现实时渲染 [Müller et al. 2022; Reiser et al. 2023]。特别是3D高斯绘制（3DGS）[Kerbl et al. 2023] 表明，基于显式图元的表示方法能够很好地结合高视觉质量、快速训练和实时渲染的优点。然而，无论底层表示方法的效率如何，训练和渲染的可用资源限制了能够以高质量表示的场景规模。我们提出了一种新的分而治之的解决方案，通过引入一种新的3D高斯层次结构，允许优化内部节点并提供LOD渲染器，从而使得场景规模比大多数先前方法扩大了一个数量级。

大多数先前的神经辐射场方法无法扩展到非常大的场景，这是由于其隐式表示的性质以及依赖于加速计算的网格结构，这些结构通常具有立方级的内存增长 [Sun et al. 2022]。尽管存在一些例外 [Meuleman et al. 2023]，例如BlockNeRF [Tancik et al. 2022]，但这些解决方案所需的训练和渲染资源仍然极高，并且尚未展示这些方法的实时渲染能力。

另一方面，3DGS是一种基于图元的光栅化方法，为处理大规模场景的分而治之和LOD渲染提供了可能。不幸的是，原始3DGS表示的内存需求迅速变得过大，即使是高端GPU也无法处理，使得渲染此类场景变得不可能；训练所需的内存开销甚至更高。因此，为了训练和渲染非常大的场景，我们引入了：a）一种分而治之的方法，允许在可管理的资源下对完整场景的较小部分（或块）进行训练，并且最好允许并行处理块；b）一种层次结构，允许快速渲染远处内容，构建高效，能够快速选择切分并平滑插值，从而在视觉质量和速度之间提供良好的权衡。

尽管每个场景块可以像原始3DGS方法中那样简单地进行优化，但大规模场景捕获（例如车载设备捕获）通常比常见的辐射场数据集稀疏得多；因此，我们调整了每个块的优化以适应这种类型的输入数据。为了实现LOD渲染，我们为3DGS提出了一个层次结构，通过基于局部几何和体积属性定义3DGS图元的合并方法。我们的层次结构允许高效选择切分和平滑插值。此外，我们的层次结构还允许进一步优化中间节点的属性；这一步骤补充了最初基于局部和纯几何构造的层次结构，并提高了整体视觉质量。最后，我们将所有块的层次结构整合在一起，通过一个小的清理步骤移除不必要的层次节点。然后，我们可以使用我们的LOD层次结构实现实时渲染。

我们在多个数据集上展示了我们的方法：一个由Wayve提供的数据集，以及我们自己使用安装在自行车头盔上的5或6台GoPro相机捕获的三个数据集。这些数据集覆盖了从450米到数公里的距离，包含5800到28000张图像；我们的方法允许在3D中进行实时导航。

我们的贡献可以总结如下：
- 一种新的3DGS层次结构，允许高效选择层次和平滑插值。
- 一种优化我们层次结构内部节点的方法，提高视觉质量。
- 基于块的分而治之的大场景训练和渲染方法。

我们的方法能够并行训练非常大场景的各个块，并且是第一个具有完整动态LOD的解决方案，允许对如此规模的场景进行实时渲染。我们的解决方案能够适应可用资源，并且可以使用廉价的消费级设备进行捕获；这使得对街区级场景的捕获和渲染对任何人都是可行的。

我们将发布我们的源代码，包括所有支持捕获和校准的代码。我们还计划发布我们的大规模捕获数据。


## 2 相关工作
我们的研究重点是大规模场景，涉及在地面上跨越数公里距离的数万张输入图像。尽管新型视图合成（Novel View Synthesis, NVS）和神经渲染领域取得了令人印象深刻的进展，但很少有方法能够处理我们所针对的如此规模和复杂性的环境。我们简要介绍最相关的工作，重点关注那些尝试处理大规模场景的研究，这些研究使用了网格、神经场或基于点的表示方法。

### 基于图像和网格的重建
基于图像和网格的重建方法传统上被用于不同规模的场景，从小型场景 [Chaurasia et al. 2013] 到中型场景（如一个房间或几栋建筑）[Buehler et al. 2023; Hedman et al. 2018; Jain et al. 2023; Riegler and Koltun 2021]，再到城市级数据 [Bódis-Szomorú et al. 2016]。这些方法存在一个共同的缺点：它们严重依赖于精确的网格。不幸的是，这些网格——通常通过运动恢复结构（Structure-from-Motion, SfM）[Snavely et al. 2006] 的变体获得，随后使用多视图立体视觉 [Seitz et al. 2006]——在处理植被、细结构以及非朗伯体或无纹理材料等复杂情况时会失败。所有这些情况在从街道层面捕获的标准城市景观中频繁出现。其他方法通过SfM构建的3D网格框架实现快速渲染 [Liu et al. 2023a; Riegler and Koltun 2021]。这些特征可以在渲染时进行优化 [Liu et al. 2023a]，或在表面聚合步骤之前从图像中提取 [Riegler and Koltun 2021]。由于它们严重依赖网格，这些方法在恢复精细结构方面不够准确，并且像其他同时考虑整个数据的方法一样，它们不具备任意可扩展性。尽管在捕获城市数据方面已有大量工作 [Lin et al. 2022; Zhang et al. 2021; Zhou et al. 2020]，但这些工作的重点倾向于航拍数据，而不是我们这里所关注的街景数据。

### 辐射场重建与渲染
神经辐射场（Neural Radiance Fields, NeRFs）[Mildenhall et al. 2020] 用于重建有界的场景的体积辐射场，通常围绕单个对象展开。Mip-NeRF [Barron et al. 2021] 实现了适当的抗锯齿功能，以处理多尺度观测。与此同时，NeRF++ [Zhang et al. 2020] 解除了有界场景的限制，而Mip-NeRF 360 [Barron et al. 2022] 将适当的抗锯齿表示的优势应用于无界对象中心场景。这些方法以高质量重建小范围感兴趣区域，同时通过空间收缩压缩背景。基于体素的表示方法 [Karnewar et al. 2022; Sun et al. 2022] 已被广泛研究，以提高这些方法的优化和渲染速度。然而，所有这些方法的基于场的隐式性质自然地暗示了重建质量和场景体素表示的立方增长之间的权衡。这种权衡可以通过使用哈希网格 [Müller et al. 2022] 或张量分解 [Chen et al. 2022] 进行压缩和空格跳过来部分解决。F2-NeRF [Wang et al. 2023] 进一步发展，去除了以对象为中心的场景假设，并根据任意相机轨迹高效分配表示能力。其他基于NeRF的方法 [Barron et al. 2023; Duckworth et al. 2023; Wu et al. 2022; Zhang et al. 2022] 展示了在室内场景（如公寓）中扩展的能力；我们处理的城市级数据集在范围和图像数量上都要大一个数量级。

最近引入的3D高斯绘制（3D Gaussian Splatting, 3DGS）[Kerbl et al. 2023] 是第一个在无界场景中实现高视觉质量的同时保持快速训练和实时渲染的方法。对我们来说，3DGS的一个重要优势是它放弃了基于隐式场的解决方案，采用了一种基于图元的表示方法 [Keselman and Hebert 2022]，这种方法在优化之前不需要预先分配数据结构。这使得它可以支持任意的相机路径，并在必要时动态分配表示能力。尽管任意的相机路径对3DGS来说不是问题，但任意大的场景最终会耗尽资源，使得在这些场景中使用3DGS变得不可行。我们通过引入第一个可以优化并提供高效细节层次（Level-of-Detail, LOD）解决方案的3DGS层次结构，解决了资源饱和问题，并结合分而治之的技术将环境划分为更小的部分。

### 细节层次渲染
细节层次（Level-of-Detail, LOD）方法是计算机图形学中一个非常成熟的部分 [Luebke 2003]。最近，类似的想法被应用到神经辐射场 [Takikawa et al. 2022; Xiangli et al. 2022] 和学习的符号距离函数 [Takikawa et al. 2021] 中。在实时渲染应用中，LODs可以根据启发式规则或目标资源预算，在任何时间点调节显示的细节量。LODs提供了必要的优化，并且通常是真正可扩展渲染解决方案的基石 [Karis et al. 2021]。调整细节量的能力为开发者和用户提供了灵活性。LODs已经被提出用于基于点的表示 [Dachsbacher et al. 2003; Rusinkiewicz and Levoy 2000]，但3DGS的双重体积/可光栅化性质及其优化过程提出了我们在这里解决的具体挑战。尽管场景的简单近似（例如，使用体素网格或量化 [Schütz et al. 2021]）已经可以被视为一种LOD，但一个适合交互场景的完整方法必须同时解决三个挑战：生成具有多个细节层次的LOD结构、为给定视图选择适当层次的策略，以及在它们之间转换而不产生破坏性伪影的能力。我们的层次结构满足了这些要求，并提供了一个适合实时渲染的解决方案。

### 城市级重建
很少有研究解决方案能够处理城市级场景，因为这个问题的复杂性。此外，丰富的高质量数据并未公开可用。我们希望计划中的数据集公开发布能够在这方面有所帮助。BungeeNeRF [Xiangli et al. 2022] 在渐进优化过程中需要特定的数据：从卫星捕获到更近的视图。因此，它不适合于城市级地面数据捕获（即使有时包含额外的航拍镜头）。NeuRas [Liu et al. 2023b] 使用多视图立体视觉重建和优化的神经纹理来建模城市场景，这些场景仅涵盖几秒钟的驾驶镜头，这比本文的目标小得多。DrivingGaussians [Zhou et al. 2023] 基于3DGS构建，但它们从nuScenes [Caesar et al. 2022] 和 KITTI360 [Liao et al. 2022] 重建场景，这些场景的范围很容易适应它们的硬件配置。

分而治之的解决方案将场景划分为独立的块或块；我们也采用了这种策略。在辐射场的背景下，KiloNeRF [Reiser et al. 2021] 引入了这种解决方案来解决性能问题，但后来同样的想法被用于大规模场景 [Dhiman et al. 2023; Meuleman et al. 2023; Tancik et al. 2022; Turki et al. 2022]。与我们方法最接近的是BlockNerf [Tancik et al. 2022]，它将场景划分为重叠50%的部分，并为每个部分计算一个NeRF。然而，展示的NeRF方法训练和渲染都非常缓慢。相比之下，我们提出了一种方法，允许在短暂的粗初始化之后对每个块进行快速训练，并且最重要的是允许实时渲染。


## 3 概述与背景
我们致力于解决如何优化非常大场景的挑战，以创建一个可以实现实时渲染的层次化辐射场。首先，我们需要解决优化资源有限的问题，因为这些数据通常比传统的辐射场捕获稀疏得多。我们通过将场景（图1(a)）划分为一组块（图1(b)）来解决这一问题。首先，通过对整个场景优化一组固定的、少量的3D高斯分布来创建一个粗略的框架。然后，我们独立优化每个块（图1(c)），并对3D高斯绘制（3DGS）的优化过程进行了多项改进，以处理稀疏数据（见第6.2节）。为了高效渲染远处的内容，我们为每个块引入了一个新的3DGS层次结构（图1(d)），以及一种优化内部节点属性的方法，以整体提升视觉质量。每个块的优化层次结构被压缩并整合为整个场景的完整层次化表示（图1(e)）。随后，该层次结构可用于基于细节层次（LOD）的实时渲染。

在简要介绍3DGS的背景之后，我们将介绍我们的层次结构（第4节），然后描述我们如何优化内部节点（第5节），最后讨论针对大规模场景训练的基于块的优化（第6节）。

### 3.1 背景
3DGS基于体积图元创建场景表示，每个图元包含以下参数：位置（也称为均值）$\mu$、协方差矩阵$\Sigma$（在实际应用中分解为尺度和旋转）、不透明度$o$以及用于表示外观或视角相关颜色的球谐系数（Spherical Harmonics, SH）。这些三维图元被投影到二维屏幕空间，并通过α混合进行光栅化。α混合的权重为：

$$
\alpha = oG \quad (1)
$$

投影到像素$(x, y)$的高斯分布贡献为：

$$
G(x, y) = e^{-\frac{1}{2}([x, y]^T - \mu')^T \Sigma'^{-1}([x, y]^T - \mu')} \quad (2)
$$

其中，$\mu'$和$\Sigma'$是投影后的二维均值和协方差矩阵。将球谐系数转换为每视角的颜色值，并对它们进行α混合，从而重现捕获场景的外观。


## 4 3D高斯绘制的层次化细节层次（LOD）
细节层次（Level-of-Detail, LOD）解决方案在处理大规模场景时至关重要，它能够高效渲染海量内容。因此，我们的目标是创建一个层次结构，以表示原始3D高斯绘制（3DGS）优化生成的图元。遵循传统图形学中的LOD方法，我们需要：
1. 找到候选的3DGS图元，并定义如何将它们合并为中间节点；
2. 提供一种高效的方法来确定层次结构中的切分，以在质量和速度之间取得良好的权衡；
3. 提供一种在层次级别之间平滑过渡的策略。

### 4.1 层次生成
我们为每个块创建了一个基于树的层次结构，包含内部节点和叶节点。每个节点都与一个3D高斯分布相关联，它要么是来自原始优化的叶节点，要么是一个合并后的内部节点。我们对中间节点的要求是：
1. 保持与叶节点相同的快速光栅化流程；
2. 尽可能准确地表示子节点的外观。

因此，我们需要定义中间节点，这些节点是具有3DGS图元所有属性的3D高斯分布，即均值$\mu$（位置）、协方差$\Sigma$、球谐系数（SH）和不透明度（见第3节）。

对于均值和协方差，有大量的文献与高斯分布相关，我们在此基础上定义合并过程。具体来说，为了将$N$个高斯图元（均值为$\mu_i^{(l)}$，协方差为$\Sigma_i^{(l)}$）合并到第$l$层，使得合并节点与其子节点的加权分布之间的三维Kullback-Leibler散度最小化，我们使用以下公式 [Goldberger and Roweis 2004; Jakob et al. 2011]：

$$
\mu^{(l+1)} = \sum_{i=1}^{N} w_i \mu_i^{(l)} \quad (3)
$$

$$
\Sigma^{(l+1)} = \sum_{i=1}^{N} w_i \left( \Sigma_i^{(l)} + (\mu_i^{(l)} - \mu^{(l+1)})(\mu_i^{(l)} - \mu^{(l+1)})^T \right) \quad (4)
$$

其中，$w_i$是归一化权重，即$w_i = \frac{w_i'}{\sum_{i=1}^{N} w_i'}$。接下来，我们定义未归一化的合并权重$w_i'$，这些权重与每个子高斯分布对父节点的贡献成正比。

为了找到这些权重，我们在屏幕空间中对投影后的二维高斯分布进行推理。对于一个具有颜色$c_i$和不透明度$o_i$的独立高斯图元$g_i$，其对图像位置$(x, y)$的贡献为：

$$
C_i(x, y) = o_i c_i G(x, y) \quad (5)
$$

对整个图像的贡献为：

$$
C_i = o_i c_i \int_{X} \int_{Y} G(x, y) \, dx \, dy \quad (6)
$$

$$
= o_i c_i \sqrt{(2\pi)^2 \vert \Sigma'\vert } \quad (7)
$$

其中，$\Sigma'$是高斯分布的二维协方差矩阵的行列式。为了推导出权重，我们假设高斯分布近似各向同性，重叠较少，且透视畸变较小。在这种简化情况下，对于两个高斯分布，我们希望父高斯分布$g_p$的贡献等于两个子高斯分布$g_1$和$g_2$的总贡献。因此，我们需要父节点的$C_p$等于两个子节点的总贡献$C_1 + C_2$。如果求解所需的权重，我们可以得到以下表达式$w_i'$，用于公式(3)中，忽略与权重无关的常数因子和颜色：

$$
w_i' = o_i \sqrt{\vert \Sigma_i'\vert } \quad (8)
$$

在实际应用中，由于高斯分布的二维协方差矩阵的行列式的平方根与对应三维椭球体的（投影）表面积成正比，我们计算每个椭球体的表面积$S_i$，而不是$\sqrt{\vert\Sigma_i'\vert}$。

我们还可以使用相同的权重对合并节点的球谐系数进行加权平均：

$$
SH^{(l+1)} = SH_1^{(l)} w_1 + SH_2^{(l)} w_2 \quad (9)
$$

我们也可以使用这些权重来合并不透明度。然而，我们的合并策略改变了中间节点不透明度属性的语义。考虑图2(a)中显示的红色和蓝色3D高斯分布，它们被光栅化到屏幕上（图2(b)）。多个混合的高斯分布可能导致比高斯衰减更慢的衰减效果；例如，图2(c)中显示了α混合不透明度的曲线图，以及对应的屏幕空间中扫描线上的混合权重α_r和α_b（图2(d)）。我们看到每个单独的图元都有标准的高斯衰减。如果我们绘制α混合不透明度的累积效果，我们会看到一个更慢的衰减效果（图2(e)）。使用权重$w_i'$，我们可以绘制一个合并的高斯分布$p$，其不透明度为$\sum_{i=1}^{N} w_i' S_p$（图2(f)），并沿着扫描线绘制结果贡献（图2(g)）；我们看到这种慢衰减效果得以保持。然而，这个量现在可能大于1：因此，我们称这个值为中间节点的“衰减”，而不是不透明度。它在渲染时表现得像不透明度，但结果的α值被限制为1。

典型场景中的高斯分布可能违反上述各向同性的假设。在第5.1节中，我们描述了额外的措施来解决这些情况，并提高更高LOD级别在这种情况下的质量。

现在我们有了一个合并3D高斯分布的程序。给定一组3DGS图元，我们首先在它们之上自顶向下构建一个轴对齐的有界框（AABB）层次包围体（BVH）。我们从一个包含所有高斯图元的AABB开始，使用其存储大小的3倍来捕捉它们的范围（使用原始论文 [Kerbl et al. 2023] 中的截止值）。初始的AABB是BVH的根节点。为了获得子节点，我们对当前节点递归地执行二分中值分割。首先，我们将一组高斯分布的均值投影到它们包围盒的最长轴上。然后，我们根据每个图元投影均值相对于所有投影的中值的位置，将该组图元进行划分。得到的BVH树确保每个内部节点的子节点在空间上是紧凑的。然后，我们从叶子节点开始，递归地向上合并计算中间节点的高斯分布。

### 4.2 层次切分选择与层次切换
给定一个3DGS模型的层次树结构和一个视图$V$，我们选择一个通过树的切分，以在保持视觉质量的同时最大化渲染性能。我们首先定义一个给定层次节点$n$的粒度$\epsilon(n)$为在给定视图下屏幕上的投影大小（图3(a)）。具体来说，我们使用包含在一个节点中的叶高斯分布的包围盒，然后取包围盒的最大尺寸，并用它来计算投影大小。我们通过找到那些在屏幕上投影的包围盒小于给定目标粒度$\tau_\epsilon$（例如，1像素）的节点来确定切分。根据层次节点的生成及其边界，父节点的AABB永远不会比其子节点显得更小。这使我们能够在线性时间内找到合适的切分，或者在一个大规模并行设置中，每个节点的常数时间内找到：如果一个节点$n$的边界满足粒度条件，但其父节点不满足，那么节点$n$就被选中用于给定的设置，并包含在切分中（图3(b)中的绿色曲线）。请注意，根据这种逻辑，要么选择所有子节点，要么选择父节点。

任何层次化渲染解决方案的关键要素之一是能够在层次级别之间平滑过渡。我们通过插值各个高斯属性来实现平滑过渡。当一个节点不再适合当前的目标粒度时，它将被其子节点替换，通过插值父节点和子节点的高斯属性来实现。由层次选择返回的切分将包含满足（过度）标准的节点。通过评估切分中每个节点的粒度$\epsilon(n)$以及其父节点$p$的粒度$\epsilon(p)$，选择插值权重$t_n$。然后，插值权重$t_n$的计算公式为：

$$
t_n = \frac{\tau_\epsilon - \epsilon(n)}{\epsilon(p) - \epsilon(n)} \quad (1
0)
$$

位置、颜色和球谐系数可以使用插值权重进行线性插值。对于协方差，我们发现分别插值尺度和旋转（即使我们使用线性插值而不是更昂贵的“球面线性插值”来处理旋转）比协方差矩阵插值得到更好的外观效果。然而，高斯分布可能具有相同的形状（协方差），尽管它们在旋转和缩放方面差异显著。例如，一个沿其$x$轴缩放$s$倍的高斯分布将与一个沿其$y$轴缩放$s$倍然后绕其$z$轴旋转90°的高斯分布看起来相同（图4(a)）。因此，当直接插值它们的属性时，可能会出现不必要的旋转，这在视觉上是令人不安的。

为了避免这种情况，在层次生成过程中，我们还执行方向匹配：从根节点开始，我们递归地重新解释每个子高斯分布的方向轴，以最小化子节点与其父节点之间的相对旋转，通过穷举搜索实现。如果使用非穷举方法（例如，匹配特征值），仍然会出现不必要的旋转。

不透明度的插值也需要谨慎处理。在从父节点向子节点过渡的开始时，子节点共享父节点的所有其他属性，这些属性逐渐插值到每个单独子节点的属性（图4(b)）。然而，我们需要修改子节点的衰减，以便在过渡开始时，重叠高斯分布的混合结果与父节点相同。

我们寻找一个混合权重$\alpha'$，使得在转换开始时，子节点的混合贡献等于父节点的贡献。考虑两个子节点和一个独立父节点的简单情况。在转换点之前，父节点的混合颜色为$\alpha_p c_p$（公式1），其中$c_p$是父节点的颜色。我们需要求解$\alpha'$，使得：

$$
\alpha_p c_p = \alpha' c_p + (1 - \alpha') \alpha' c_p \quad (11)
$$

以便在转换开始时，子节点的混合颜色正好等于父节点。求解得到：

$$
\alpha' = 1 - \sqrt{1 - \alpha_p} \quad (12)
$$

在有两个子节点的情况下。这个$\alpha'$权重用于与父节点到子节点的其他属性相同的线性插值方案，为每个子节点$i$的不透明度$\alpha(t)$进行插值：

$$
\alpha(t) = t \alpha_i + (1 - t) \alpha' \quad (13)
$$

通过这种插值方案，我们实现了层次结构的平滑过渡。我们在图5中展示了针对两个不同目标粒度的层次结构的渲染结果；请参见补充视频，其中展示了平滑过渡的效果。

## 5 优化和压缩层次结构
层次结构是通过聚合几何图元构建的；最终我们需要更明确地考虑外观。由于层次结构中的每个中间节点本身就是一个3D高斯图元，因此可以进一步优化以提高视觉质量。为此，我们需要将梯度传播到中间节点，引入一个可以优化的层次结构。接下来，我们解释如何实现这一点，并额外介绍一个步骤来压缩层次结构。

传统的图形学中的LOD方法用于在远处观看时表示场景的简化版本；这在图6中有所说明。我们的目标粒度通过考虑投影屏幕面积来实现这种效果，用之前定义的节点$n$的粒度$\epsilon(n)$来表示。

### 5.1 优化层次结构
我们的自顶向下的层次结构构建得到了一个效果良好的数据结构（见表2）。然而，一旦构建完成，中间节点可以像叶3DGS图元一样进行渲染，因此也可以以相同的方式进行优化。因此，我们可以优化层次结构的中间节点，以提高它们所表示的视觉质量。这就提出了一个问题：如何在不同尺度之间进行这种优化。一种解决方案是通过随机选择输入视图和下采样因子来优化层次结构 [Barron et al. 2021]；较低的分辨率直接意味着不同的目标粒度，以及相应的层次切分。然而，这种方法存在缺点，我们在图5和图7中进行了说明：当降低分辨率时，有一些高频细节无法表示。

**解决方案**  
我们不在优化过程中进行下采样，而是在全分辨率下进行渲染，并随机选择目标粒度。这种方法可以在许多不同的切分中优化节点，同时保留视觉细节。这在资源有限的情况下特别有用，我们可以应用更激进的LOD策略，同时保持更好的视觉质量。具体来说，我们加载生成的层次结构，并通过随机选择一个训练视图和一个目标粒度$\tau_\epsilon$来进行优化。目标粒度范围为$[\tau_{\min}, \tau_{\max})$，所选的训练视图定义了相应的切分。为了在层次结构的所有级别上实现高质量采样，我们通过一个标准随机变量$\xi \in [0, 1)$来采样目标粒度$\tau_\epsilon$，使用公式：

$$
\tau_\epsilon = \tau_\xi^{\max} \tau_{1-\xi}^{\min}
$$

在优化过程中，我们同时使用切分选择和插值（第4节）。为了同时优化子节点和父节点，并启用平滑切换，我们需要正确地将梯度传播到层次结构的两层，同时优化子节点和父节点。这需要梯度通过插值权重和公式(12)中的$\alpha'$表达式进行传播。通过优化层次结构的多个级别，我们处理了一个比3DGS更复杂的设置：优化更高LOD级别可能会由于插值而降低叶节点的质量。为了避免这种情况，我们在优化过程中不改变叶节点。

需要注意的是，正如最近的研究 [Yu et al. 2023] 所指出的，原始的3DGS方法没有正确处理抗锯齿；由于层次结构在不同尺度上运行，因此需要正确的抗锯齿。因此，我们使用了Yu等人 [2023] 提出的EWA滤波解决方案。

### 5.2 压缩层次结构
层次结构在内存方面增加了一些开销。更重要的是，对于层次结构本身的优化，我们希望避免父节点的大小仅略大于子节点的情况。否则，这些节点可能很少被选中，并且在训练过程中无法得到适当的优化。为了避免这种情况，我们对生成的树结构进行稀疏化。

我们首先将所有叶节点（3DGS优化的输出）标记为相关节点，即它们不应从树中移除。接下来，我们根据第4.2节的方法，在所有训练视图上找到树中所有切分的并集，目标粒度为最小值$\tau_{\min} = 3$像素（由于低通滤波，这是3DGS图元的最小范围）。然后，我们找到这个并集中最底层的节点，这再次形成一个切分。这些节点被认为是对于选定粒度相关的最高细节节点。我们将这些节点与已经标记的节点之间的所有节点从树中移除。然后，我们将目标粒度提高2倍，并重复这个过程，直到达到$\tau_{\max}$，即图像分辨率的一半。需要注意的是，这可能导致节点有$K$个子节点，此时公式(12)推广为：

$$
\alpha' = 1 - (1 - \alpha_p) \left( \frac{1}{K} \right)
$$

## 6 大场景训练
我们现在可以构建高效的3D高斯分布层次结构；这些层次结构对于处理非常大的场景是必不可少的，因为从远处看到的场景部分可以在层次结构的较粗级别上进行渲染。为了训练大场景，我们借鉴了计算机图形学中用于实时渲染大数据的常见方法 [Luebke 2003]。特别是，我们通过将大场景划分为块（图8）来引入一种分而治之的方法。

我们将块的大小定义为步行捕获场景的50×50米到车辆捕获场景的100×100米。尽管在尺寸上有限，但这些块仍然比原始3DGS方法处理的块要大。此外，这种场景的捕获风格必然比大多数辐射场解决方案所期望的稀疏得多。因此，我们调整了3D高斯分布的优化，以适应这些差异。我们的目标是允许对各个块进行并行处理，以便在给定足够的计算资源的情况下，在合理的时间内处理大场景。一旦各个块被处理完毕，我们需要一个整合步骤来处理各个块之间可能存在的不一致性。

### 6.1 粗初始化和块划分
我们首先对整个数据集的相机进行标定；我们在第7节和附录中讨论了这一工程挑战的解决方案。为了使所有块能够一致地进行训练，我们需要为所有后续步骤提供一个基本的框架和天空盒。我们通过对整个数据集进行非常粗略的初始优化来实现这一点。具体来说，我们使用现有的SfM点启动整个场景的默认3DGS优化，并添加一个辅助天空盒（见第6.2节）。此外，我们在这一阶段禁用了密集化，并且不优化原始对象的位置，因为SfM点已经放置得很好。这个粗略模型为提供背景细节（即给定块之外的场景部分）提供了一个最小的基础。在极大规模场景的情况下，如果存储SfM点会超出（V-）RAM容量，粗略优化本身可以分解为多个步骤，中间的部分结果可以流式传输到磁盘。我们将场景划分为足够大的块，以建立常见现实世界元素（包括汽车、建筑物和纪念碑）的足够上下文。对于每个块，我们选择所有在块边界内的相机，或者在块边界内有超过50个SfM点且在块边界2倍范围内的相机。

### 6.2 块级训练
我们独立训练每个块；然后使用结果为每个块创建一个层次结构（第4节），随后进行优化和整合步骤（第6.3节）。在大规模数据集中，一个典型的块与原始3DGS设置中使用的数据有显著差异。特别是，场景的范围比Mip-NeRF 360 [Barron et al. 2022] 或Deep Blending [Hedman et al. 2018]等数据集的小场景要大得多。此外，捕获密度要低得多，且不是“以物体为中心”。这使得优化更加困难，因为射线空间没有被均匀覆盖 [Kopanas and Drettakis 2023]。数据还包含曝光变化、人类和移动物体（汽车、自行车等），这些需要在优化中被移除和忽略。

我们定义了一个围绕场景范围的天空盒，即在场景直径10倍的球体上分布100,000个3DGS原始对象，以捕捉天空的效果。我们加载了将用于块外所有内容的粗略优化场景；它还防止每个块为天空创建不一致的内容。我们使用3DGS优化 [Kerbl et al. 2023] 训练块内的内容，并使用正确的抗锯齿技术 [Yu et al. 2023]。我们对块外的粗略环境和天空盒进行了小的、临时的优化。具体来说，我们只优化不透明度和球谐系数。

原始3DGS优化通过收集统计数据来决定是否在固定次数的迭代后对高斯分布进行密集化。具体来说，密集化策略基于屏幕空间位置梯度的均值。在无界场景的背景下，存在两个主要问题。首先，无论高斯分布是否足够精细以模拟局部细节，这一策略很少阻止高斯分布的密集化。其次，对于稀疏分布的相机观察场景的不同部分的数据集（例如，城市驾驶场景捕获），整体上更倾向于不密集化。我们通过将密集化策略改为考虑观察到的屏幕空间梯度的最大值而不是均值来解决这两个问题，因为在稀疏捕获的背景下，均值不再可靠。

我们拥有的稀疏相机捕获无法为高质量重建提供足够的信息，例如在城市驾驶场景中的街道。我们执行单目深度预测，根据SfM点对深度进行缩放和平移，并将其用于正则化优化。这在视觉质量上取得了改进，特别是对于道路（见第8节）。我们在附录C中提供了这一过程的详细信息。

### 6.3 块整合与渲染
每个块都从COLMAP（第7.2节）的每块细化中的SfM点开始，并包含其邻近块中的框架中的3D高斯分布。因此，与块及其层次结构相关的3D高斯分布有时在块本身之外。在整合阶段，如果与块$i$相关但位于块$i$之外的原始对象更接近另一个块$j \neq i$，则将其删除。整合还创建了一个全局层次结构，为整个场景提供了一个根节点。渲染通过设置粒度阈值并找到相应的切分来执行。我们每2帧更新一次切分，通过将节点从CPU内存传输到GPU来添加细节，并每100帧运行一次清理。


## 7 实现、数据捕获与预处理
接下来，我们详细介绍实现过程以及数据集的捕获和预处理。

### 7.1 实现
我们在原始3DGS（3D高斯分布）的实现基础上，使用C++和Python/PyTorch实现了我们的方法，并修改了SIBR [Bonopera et al. 2020] 观测器以实现快速渲染。我们将在论文发表时提供所有源代码和数据，包括所有数据集预处理的脚本（见项目页面）。我们使用PyTorch提供的自动微分功能进行层次优化，除了手动推导的方程12的梯度外。此外，在层次优化过程中，我们通过在层次结构中所有对应于叶节点的高斯分布上使用停止梯度操作符，避免优化叶节点，从而有效地冻结了它们的属性。

### 7.2 数据集捕获与预处理
我们捕获了三个户外场景：SmallCity、BigCity和Campus，并在表1中列出了每个场景的统计数据，以及Wayve提供的一个额外场景的统计数据。

**数据捕获**  
在我们的数据捕获中，我们使用了一个安装了6台相机（Campus数据集为5台）的自行车头盔（见图9）。我们使用了GoPro HERO6 Black相机，设置为线性视场（Linear FoV），分辨率为1444×1080，以0.5秒的时间间隔进行延时拍摄模式。我们在骑自行车时（速度约为6–7公里/小时）捕获了SmallCity和BigCity数据，而Campus数据则是通过步行佩戴头盔捕获的。

**姿态估计**  
姿态估计是我们处理的相机数量的一个主要挑战。我们的数据集包含5800到40000张照片。我们使用COLMAP，并通过定制参数设置、层次化映射器以及额外的每块捆绑调整来实现合理的处理时间。详细信息请参见附录B。

**数据集处理**  
我们通过优化每张图像的曝光校正来校正曝光，这与其他方法类似 [Martin-Brualla et al. 2021; Müller et al. 2022]。最后，我们通过运行基于CNN的分割来识别汽车、自行车等移动物体，并确定它们是否有对应的SfM（Structure from Motion）点，从而移除这些移动物体。我们还移除了所有人物和车牌。所有步骤的详细信息均在附录中提供。

### 7.3 层次优化
一些中间节点会生成α值大于1的情况，这是为了使合并后的高斯分布能够表示更不透明的原始对象，并延迟衰减（参见第4节）。然而，在这些节点存在的情况下，我们无法在训练过程中应用原始3DGS的不透明度指数激活函数。相反，我们使用绝对值激活函数进行后优化。由于α混合值在光栅化过程中已经被内部限制为0.99，因此不需要对3DGS的前向过程进行额外更改。然而，为了确保鲁棒性，我们必须考虑这个限制步骤，并在出现时将高斯分布的不透明度梯度置为零。


## 8 结果与评估
我们在四个捕获的场景（SmallCity、BigCity、Campus）以及Wayve提供的一个场景上展示了我们的方法（见图8和图10）。

### 8.1 结果
结果在补充视频中得到了最佳展示，我们在视频中展示了如何在捕获的大型场景中实时导航。视频中展示的路径覆盖了整个捕获区域，以展示其规模之大。对于每个场景，我们都会停下来展示一个自由视角的环绕查看。这在相机密度较高的区域表现得尤为出色，例如多次捕获路径交叉的地方等。我们的最小场景SmallCity仅包含一个城市街区。我们在Campus和Wayve场景中覆盖了超过1公里的距离，在BigCity场景中覆盖了数公里的距离。在训练过程中，这些场景被划分为4、11、22和46个块。每个块包含200万到800万片叶高斯分布。粗优化、单块优化和层次优化分别在一台NVIDIA V100 GPU（32 GB）上各需1小时，峰值内存使用量分别为2–5 GB、8–10 GB和11–16 GB。经过每块优化和整合后，层次化场景的磁盘大小分别为6 GB、17 GB、27 GB和88 GB，比非层次化的3DGS文件大约大68%。尽管整体质量良好，但仍存在一些伪影。大多数视觉伪影是由于这些大规模捕获的稀疏性造成的：与传统的辐射场捕获不同，场景中的一个点通常只被少数几个相机看到。其他伪影是由于场景中的干扰物没有完全移除造成的：我们能够移除大多数移动的车辆，但那些停下来或减速的车辆没有被正确识别，导致数据不一致和优化效果不佳。开发一个完整的解决方案来解决这个问题与我们的贡献正交（参见第9节和附录A、B）。我们还在视频中展示了层次结构之间渐进插值的效果。



### 8.2 评估
与其他方法进行比较是困难的，因为没有其他公开代码的方法能够处理我们这样大规模的场景。因此，我们决定在单个块上比较我们的方法的质量，因为这些块可以被先前的方法合理地处理。所有方法（包括我们的方法）接收相同的输入，即仅属于该块的图像。特别是，我们将我们的方法与F2-NeRF、Instant-NGP、原始3DGS、Mip-NeRF 360和MegaNeRF [Turki et al. 2022]进行了比较。最后，我们对方法中的几个元素进行了消融实验，以证明每个相应算法组件的重要性。所有实时渲染结果和性能指标都是在NVIDIA A6000 GPU上收集的。

**与其他方法的比较**  
在图10和补充视频中，我们将我们的方法与先前的方法进行了比较，展示了定量比较的视觉结果。这些结果展示了我们方法在稀疏捕获上的两个主要改进：深度监督和改进的密度化策略。我们在数据集上进行了定量评估，通过从训练中排除每台相机的每50张图像（按字母顺序排列），这些图像随后被用于测试。我们为每种方法计算了标准误差指标PSNR、LPIPS和SSIM（见表2）。表的第一部分显示了我们的方法仅在一个块上运行的结果，没有使用层次结构，仅使用该块的相机。由于其他方法默认不考虑曝光变化，我们禁用了曝光优化。这对我们来说是一个“受限”的比较，因为我们的方法的优势在于能够处理整个场景，但它允许与他人进行“公平”的比较，因为每种方法都从相同的数据开始。我们发现，对于大多数情况下比先前方法中使用的块更大的块，我们的方法优于所有先前的方法。

为了评估我们方法的灵活性，我们在已建立的小规模Mip-NeRF 360数据集上评估了我们单块优化的结果。我们的方法并不是针对这种场景设计的。与原始3DGS相比，我们的单块优化在整个数据集上平均实现了类似的质量，PSNR分别为29.11 dB（他们的）和28.96 dB（我们的）。与3DGS的差异是由于我们针对块大小场景调整了训练。对于层次级别τ₁、τ₂和τ₃，基本/优化层次的PSNR结果分别为28.86 dB/28.87 dB、28.05 dB/28.52 dB和24.82 dB/27.25 dB。

鉴于没有其他方法能够处理这种规模的街景数据，我们尽最大努力与MegaNeRF [Turki et al. 2022]进行了比较，该方法能够处理大规模场景，尽管它是在航拍摄影上进行测试的。我们在作者提出的Mill 19数据集上比较了我们的方法与他们的方法。我们使用MegaNeRF数据发布提供的pixSFM [Lindenberger et al. 2021]相机姿态。由于这些数据集缺乏SfM点，我们使用COLMAP匹配器（100个邻近帧）和三角测量器生成3D点。然后我们将场景缩放到度量单位。我们使用200×200米的块分割场景，分别得到Building和Rubble场景的2个和4个块。我们将图像下采样4倍，并通过将测试视图的左半部分包含在训练集中，使用剩余部分进行测试，优化测试视图的曝光仿射变换，这与MegaNeRF的代码发布一致。表3显示，尽管我们的方法没有针对航拍数据进行调整，但我们的方法仍然具有竞争力。最重要的是，MegaNeRF报告在8个NVIDIA V100 GPU上训练时间为27到30小时，而我们的方法在两个（Building）和四个（Rubble）V100 GPU上仅需3小时，并且能够实现实时渲染。

**评估层次结构的质量**  
在表2的第二部分中，我们通过在完整场景上运行我们的层次化方法，并为同一块提供定量结果，评估了我们方法的各种选项。特别是，我们展示了在不同目标粒度下使用未优化层次结构（“Ours”）进行渲染时对图像指标的影响。正如预期的那样，当在层次结构中向上移动时，质量会下降。对于优化后的层次结构（第5.1节，“Ours opt”），我们发现在最细粒度目标下，解决方案的性能相似。然而，当选择层次结构中较粗的切分时，优化改善了结果，这正是这一步的主要目标。实际上，这意味着在给定的计算预算下，优化后的层次结构提高了视觉质量。

**性能分析**  
为了分析我们在单块场景中的渲染性能，表4提供了原始3DGS渲染和我们的LOD启用原型在不同阶段花费的时间的详细分解。除了原始流程外，我们还在每一帧中计算插值权重（权重），如第4.2节所述。这增加了1.5到4毫秒的额外成本。我们观察到，与3DGS相比，我们的方法（叶子）在预处理（即投影和评估溅射属性）和alpha混合阶段都存在开销。前者是由于加载了两倍的数据以产生插值的高斯属性。后者是由于计算辅助混合权重α′的相对昂贵的pow指令造成的。然而，对于τε = 6，我们的LOD机制显著减少了工作量，因此我们可以加速这些阶段，与3DGS相比。cut/expand*同时更新切分，并将（未来）所需的高细节高斯分布排队以进行传输。尽管它相对较慢，但实际上，这一阶段与渲染异步运行，因此不会影响实时性能。

**大规模场景渲染的运行时分析**  
我们已经评估了我们的方法在显示完整的大规模场景时的速度和资源使用情况，按照我们随附视频中显示的相机路径。所有路径在高质量设置τ₁下平均帧率超过30 FPS，在中等设置τ₂下约为60 FPS。我们注意到，由于它们的规模，Campus和BigCity无法在我们的测试系统上使用原始3DGS渲染器运行；Wayve超出了NVIDIA RTX 4090的容量，SmallCity超出了中端NVIDIA RTX 4080的容量。表5报告了在记录的路径上渲染的高斯分布的数量，作为总计数和3DGS（理论上）需要处理的百分比。我们的LOD机制有效地限制了负载和内存消耗；场景越大，减少越多。节点和边界信息将每个高斯分布的理论内存占用提高到284字节。我们当前的实现，包括方便的结构，每个高斯分布使用400字节（比3DGS多69%）。我们还报告了每帧平均传输的高斯分布数量。


## 8.3 消融实验
我们进行了几项消融实验，以评估算法不同方面的效果。在图11中，我们展示了层次结构整合和深度监督对结果的视觉效果。显然，通过移除冗余的框架高斯分布进行整合对视觉质量至关重要。对于城市场景，我们发现如果不使用深度数据，视图外推能力可能会降低。尽管深度监督并未改善每张图像的指标（参见表6中的定量单块消融实验），我们注意到，其包含对于道路的外观质量提升尤其有帮助，因为道路通常缺乏显著的特征。

我们还展示了每个块的额外捆绑调整步骤的效果；COLMAP层次化映射器仅提供近似的相机姿态，需要进一步优化。这些高保真度的姿态显著减少了模糊并增加了细节。最后，我们展示了曝光补偿和层次优化的效果：前者移除了试图模拟图像之间强度差异的多余高斯分布。后者改善了层次结构中中间节点的质量，使远处物体的形状和轮廓更加清晰。

除了上述内容外，对于Wayve的一个单块，我们进一步考察了在层次优化中包含或排除我们平滑插值的效果。在训练和评估中排除插值会导致PSNR指标分别为25.21 dB、24.73 dB和23.44 dB（对应于粒度设置τ₁、τ₂和τ₃），这表明在多个层次级别上质量明显下降（与表2中的结果进行比较）。



## 9 限制、讨论与未来工作
我们的结果显示了一些视觉伪影。这些伪影的大部分是由于输入数据造成的：视图空间覆盖不足、校准不良、移动干扰物（人类、车辆，尤其是停车的车辆等）。解决这些问题与我们的方法正交，尽管辐射场可能会帮助解决其中一些问题。对于我们展示的数据集，在环境的大部分区域，辐射场的外推能力是有限的。这是由于捕获数据有限，但未来工作中使用高质量先验 [Warburg et al. 2023] 可能会显著增强自由视角导航的能力，即使使用我们展示的这种捕获数据。

3DGS层次结构可能还有其他应用，允许辐射场成为计算机图形学中的一级表示：它可以用于创建辐射场的场景图表示，用于动画、碰撞检测等。我们的当前解决方案可以显著减少每帧渲染的高斯分布数量，从而减少资源需求并增强灵活性：与其使用固定的粒度，不如在我们的原型中添加动态LOD选择，以便在给定的资源预算下产生最佳质量。为了进一步提高效率，可以引入基于可见性和距离的截止机制。我们将这些考虑留给未来的工作。



## 10 结论
我们提出了第一个能够处理跨越数公里距离、包含数万张输入图像的街景级场景的新型视图合成方法，并支持实时渲染。为此，我们引入了三个贡献：首先，高效的3D高斯层次结构，允许平滑的细节层次（LOD）机制，用于高效显示大规模场景；其次，优化这种层次结构的能力，改善了质量和速度的权衡；最后，一种基于分而治之的块算法，用于优化层次化表示，允许并行处理独立的块，使得处理包含数万张图像的场景仅需几小时。最重要的是，我们的系统允许实时渲染这些场景，使捕捉和导航大规模环境的能力对每个人都是可访问的。
