---
layout: mypost
title: Bitcoin, A Peer-to-Peer Electronic Cash System
categories: [bitcoin]
---

# 链接

- [Bitcoin: A Peer-to-Peer Electronic Cash System](https://bitcoin.org/en/bitcoin-paper)




# 原文翻译

**比特币：一种点对点的电子现金系统**

**中本聪**  
satoshin@gmx.com  
www.bitcoin.org  

## 摘要  

一个纯粹的点对点电子现金系统将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名提供了部分解决方案，但如果仍然需要一个可信的第三方来防止双重支付，那么主要的好处就会丧失。我们提出了一种使用点对点网络解决双重支付问题的方案。网络通过将交易哈希并将其嵌入到一个基于哈希的“工作量证明”链中来对交易进行时间戳标记，形成一个不可更改的记录，除非重新完成工作量证明。最长的链不仅证明了见证事件的顺序，还证明了它来自最大的CPU算力池。只要大多数CPU算力由不合作攻击网络的节点控制，它们就会生成最长的链并超越攻击者。网络本身几乎不需要结构。消息以尽力而为的方式广播，节点可以随意离开和重新加入网络，接受最长的工作量证明链作为他们离开期间发生事件的证明。



## 1. 引言  

互联网上的商业活动几乎完全依赖于金融机构作为可信的第三方来处理电子支付。尽管这种系统对大多数交易来说运行良好，但它仍然存在基于信任模型的固有弱点。完全不可逆的交易实际上是不存在的，因为金融机构无法避免调解争议。调解成本会增加交易成本，限制了最小实际交易金额，并切断了小额偶发交易的可能性。此外，由于无法进行不可逆支付，非可逆服务的支付能力也会丧失。由于存在逆转的可能性，信任的需求会扩散。商家必须对客户保持警惕，向他们索要比其他情况下更多的信息。一定比例的欺诈被视为不可避免的。这些成本和支付不确定性可以通过使用实物货币在场交易来避免，但目前还没有一种机制可以在没有可信方的情况下通过通信渠道进行支付。  

我们需要一种基于密码学证明而非信任的电子支付系统，允许任意两个愿意的参与者直接进行交易，而无需信任第三方。计算上不可逆的交易将保护卖家免受欺诈，而常规的托管机制可以轻松实现以保护买家。在本文中，我们提出了一个使用点对点分布式时间戳服务器生成交易时间顺序的计算证明来解决双重支付问题的方案。只要诚实节点集体控制的CPU算力超过任何合作攻击节点的算力，系统就是安全的。



## 2. 交易  

我们定义一个电子货币为一个数字签名链。每个所有者通过数字签名前一次交易的哈希值和下一个所有者的公钥，并将这些添加到货币的末尾，从而将货币转移给下一个所有者。收款人可以通过验证签名来验证所有权链。  

当然，问题在于收款人无法验证其中一个所有者是否没有对该货币进行双重支付。一个常见的解决方案是引入一个可信的中央权威机构或造币厂，检查每一笔交易是否出现双重支付。每次交易后，货币必须返回造币厂以发行新货币，只有直接从造币厂发行的货币才被认为是可信的，不会被双重支付。这种解决方案的问题在于，整个货币系统的命运取决于运营造币厂的公司，每一笔交易都必须经过他们，就像银行一样。  

我们需要一种方法让收款人知道之前的拥有者没有签署任何更早的交易。对于我们的目的来说，最早的交易是最重要的，所以我们不关心之后的双重支付尝试。确认没有交易的唯一方法是知晓所有交易。在基于造币厂的模型中，造币厂知晓所有交易并决定哪一个先到达。为了在没有可信方的情况下实现这一点，交易必须公开宣布[^1^]，我们需要一个系统让参与者就它们接收的顺序达成一致的历史记录。收款人需要证明在每次交易时，大多数节点都同意它是第一个收到的。



## 3. 时间戳服务器  

我们提出的解决方案从时间戳服务器开始。时间戳服务器通过对要时间戳标记的一组数据进行哈希处理，并广泛发布该哈希值（例如在报纸或Usenet帖子中）[^2^][^5^]。时间戳证明了数据必须在当时已经存在，才能被哈希处理。每个时间戳都包含前一个时间戳的哈希值，形成一个链，每个额外的时间戳都加强了之前的时间戳。


## 4. 工作量证明

为了在点对点的基础上实现分布式时间戳服务器，我们需要使用类似于Adam Back的Hashcash的工作量证明系统[^6^]，而不是报纸或Usenet帖子。工作量证明涉及扫描一个值，当对其进行哈希处理时（例如使用SHA-256），哈希值以一定数量的零位开头。所需的零位数量越多，平均工作量呈指数增长，而验证只需执行一次哈希。

在我们的时间戳网络中，工作量证明通过在区块中增加一个随机数（nonce），直到找到一个使区块哈希值满足所需零位数量的值[^6^]。一旦CPU努力被投入以满足工作量证明，该区块就无法被更改，除非重新完成工作。随着后续区块被链接到该区块之后，更改该区块的工作量将包括重新完成该区块以及其后所有区块的工作量。

工作量证明还解决了在多数决策中确定代表权的问题。如果多数决策基于“一个IP地址一票”，那么任何能够分配大量IP地址的人都可以篡改系统。工作量证明本质上是“一个CPU一票”。多数决策由最长的链表示，这条链投入了最多的工作量证明。如果大多数CPU算力由诚实节点控制，那么诚实的链将增长得最快，并超越任何竞争链。攻击者若想修改一个过去的区块，他必须重新完成该区块及其后所有区块的工作量证明，并且在诚实节点完成后续工作之前赶上并超越它们。我们稍后会展示，随着后续区块的增加，攻击者赶上的概率会呈指数级下降[^8^]。

为了应对硬件速度的提高以及运行节点的兴趣随时间的变化，工作量证明的难度由一个移动平均值决定，目标是平均每小时产生一定数量的区块。如果区块生成速度过快，难度就会增加[^6^]。



## 5. 网络

运行网络的步骤如下：

1. 新的交易被广播到所有节点。  
2. 每个节点将新的交易收集到一个区块中。  
3. 每个节点为其区块寻找一个困难的工作量证明。  
4. 当一个节点找到一个工作量证明时，它将该区块广播到所有节点。  
5. 节点只有在区块中的所有交易都是有效且未被消费的情况下才会接受该区块。  
6. 节点通过在链中创建下一个区块，并使用已接受区块的哈希值作为前一个哈希值，来表达对区块的接受。  

节点始终认为最长的链是正确的，并将继续努力扩展它。如果两个节点同时广播下一个区块的不同版本，一些节点可能会先收到其中一个。在这种情况下，它们会先处理第一个收到的版本，但会保存另一个分支，以防它变得更长。当找到下一个工作量证明时，分支之间的竞争将被打破，其中一个分支变得更长；那些在另一个分支上工作的节点将切换到更长的分支。

新的交易广播并不一定需要到达所有节点。只要它们到达许多节点，它们就会很快被包含在一个区块中。区块广播对丢失消息也是容忍的。如果一个节点没有收到一个区块，它会在收到下一个区块并意识到自己错过了一个区块时请求它[^6^]。



## 6. 激励机制

按照惯例，区块中的第一笔交易是一个特殊的交易，它产生一个新的货币单位，归该区块的创建者所有。这为节点支持网络提供了激励，并提供了一种将货币初始分配到流通中的方式，因为没有中央机构来发行货币。稳定地增加一定数量的新货币，类似于黄金矿工投入资源将黄金添加到流通中。在我们的情况下，投入的是CPU时间和电力[^6^]。

激励机制也可以通过交易费用来资助。如果一笔交易的输出值小于其输入值，差额就是交易费用，这笔费用将被添加到包含该交易的区块的激励价值中。一旦一定数量的货币进入流通，激励机制可以完全过渡到交易费用，并且完全无通胀[^6^]。

激励机制可能有助于鼓励节点保持诚实。如果一个贪婪的攻击者能够聚集比所有诚实节点更多的CPU算力，他将不得不在两种选择之间做出决定：要么通过窃取回他的支付来欺诈他人，要么通过生成新的货币单位来获利。他应该会发现，按照规则行事会更有利可图，因为规则会使他获得比其他所有人加起来更多的新货币，而不是破坏系统以及他自己的财富的有效性[^6^]。


## 7. 回收磁盘空间

一旦某笔交易的最新状态被足够多的区块覆盖，那么在这之前的已消费交易就可以被丢弃以节省磁盘空间。为了在不破坏区块哈希的情况下实现这一点，交易被组织成一棵**梅克尔树（Merkle Tree）**[^7^]，只有树的根哈希值被包含在区块的哈希中[^2^][^5^]。这样，旧的区块可以通过截断树的分支进行压缩，而内部哈希值则无需存储。

一个没有交易的区块头大约为80字节。假设每10分钟生成一个区块，那么每年的存储需求为：

$$
80 \text{字节} \times 6 \times 24 \times 365 = 4.2 \text{MB}
$$

截至2008年，计算机系统通常配备2GB的内存，而根据摩尔定律，内存容量每年增长约1.2GB[^9^]。因此，即使区块头需要保留在内存中，存储也根本不是问题。



## 8. 简化支付验证

即使不运行完整的网络节点，也可以验证支付。用户只需要保留最长工作量证明链的区块头副本，他可以通过查询网络节点来确认自己已经拥有了最长的链，并获取将交易链接到其被时间戳标记的区块的梅克尔分支[^7^][^2^][^5^]。他无法自行验证交易，但通过将其链接到链中的一个位置，他可以看到网络节点已经接受了这笔交易，而后续添加的区块进一步确认了网络对这笔交易的接受。

只要诚实节点控制着网络，这种验证方法就是可靠的，但如果网络被攻击者控制，它就更容易受到攻击。尽管网络节点可以自行验证交易，但简化的方法可能会被攻击者制造的虚假交易欺骗，只要攻击者能够持续控制网络。一种防范策略是，当网络节点检测到无效区块时，向用户发送警报，提示用户的软件下载完整的区块和被警告的交易，以确认不一致之处[^9^]。频繁接收支付的企业可能仍然希望运行自己的节点，以获得更独立的安全性和更快的验证速度。



## 9. 价值的合并与拆分

尽管可以单独处理每枚货币，但在转账时为每一美分都创建单独的交易是不切实际的。为了允许价值的拆分和合并，交易包含多个输入和输出。通常情况下，交易会有一个来自更大金额的前一笔交易的单一输入，或者将多个较小金额的输入合并起来，最多有两个输出：一个用于支付，另一个将找零（如果有）返回给发送者[^9^]。

需要注意的是，交易的“扇出”（fan-out）在这里并不是问题。一笔交易依赖于多笔交易，而这些交易又依赖于更多交易，这种结构并不会带来问题。因为从未需要提取一笔交易历史的完整独立副本[^9^]。



## 10. 隐私

传统银行模式通过限制信息访问权限来实现隐私，只有交易双方和可信的第三方能够看到交易信息。然而，公开宣布所有交易的做法排除了这种方法，但隐私仍然可以通过另一种方式保持：通过保持公钥的匿名性[^9^]。公众可以看到有人向另一个人发送了一笔金额，但没有信息将交易与任何人联系起来。这类似于证券交易所发布的信息，其中个人交易的时间和金额（“行情”）被公开，但不透露交易双方的身份[^9^]。

作为一种额外的防火墙，每笔交易都应该使用一个新的密钥对，以防止它们被链接到同一个所有者。然而，在多输入交易中，仍然不可避免地会有一些链接，因为这些输入必然揭示了它们属于同一个所有者[^9^]。如果一个密钥的所有者身份被暴露，那么链接可能会揭示其他属于同一个所有者的交易。


## 11. 计算

我们考虑一个攻击者试图生成一个比诚实链更快的替代链的场景。即使这得以实现，也不会使系统对任意更改开放，例如凭空创造价值或窃取从未属于攻击者的资金。节点不会接受无效交易作为支付，诚实节点也永远不会接受包含这些交易的区块。攻击者只能尝试更改他自己的某笔交易，以收回他最近花费的资金。

诚实链与攻击者链之间的竞争可以被描述为一个**二项随机游走（Binomial Random Walk）**。成功事件是诚实链通过一个区块的扩展而增加其领先优势 +1，而失败事件是攻击者链通过一个区块的扩展而减少差距 -1。

攻击者从给定的落后距离追上来的概率类似于**赌徒破产问题（Gambler's Ruin problem）**。假设一个拥有无限信用额度的赌徒从落后开始，并进行潜在的无限次试验以试图达到收支平衡。我们可以计算他最终达到收支平衡的概率，或者攻击者最终追上诚实链的概率如下[^8^]：

设：
- $p$ = 诚实节点找到下一个区块的概率  
- $q$ = 攻击者找到下一个区块的概率  
- $q_z$ = 攻击者从落后 $z$ 个区块追上的概率

则：
$$
q_z =
\begin{cases}
1 & \text{如果 } p \leq q \\
\left(\frac{q}{p}\right)^z & \text{如果 } p > q
\end{cases}
$$

假设 $p > q$，随着攻击者需要追上的区块数量增加，概率会呈指数级下降。如果攻击者不能在早期幸运地向前冲刺，那么随着他进一步落后，他的机会将变得微乎其微。

我们现在考虑接收一笔新交易的接收者需要等待多长时间，才能确信发送者无法更改这笔交易。我们假设发送者是一个攻击者，他希望让接收者相信他支付了一段时间，然后试图将其切换为支付给自己。接收者会在那一刻收到警报，但发送者希望为时已晚。

接收者生成一个新的密钥对，并在签名前不久将公钥交给发送者。这可以防止发送者通过持续工作提前准备一个区块链，直到他足够幸运地领先足够多，然后在那一刻执行交易。一旦交易发送，不诚实的发送者开始秘密地在一个包含他交易替代版本的并行链上工作。

接收者等待这笔交易被添加到一个区块中，并且在其后链接了 $z$ 个区块。他不知道攻击者取得了多大的进展，但假设诚实区块以每个区块的平均预期时间生成，攻击者的潜在进展将是一个泊松分布，其期望值为：

$$
\lambda = z \cdot \frac{q}{p}
$$

为了计算攻击者现在仍然可能追上的概率，我们将泊松密度乘以他可能取得的每种进展程度的概率：

$$
\sum_{k=0}^{\infty} \frac{\lambda^k e^{-\lambda}}{k!} \cdot
\begin{cases}
\left(\frac{q}{p}\right)^{z-k} & \text{如果 } k \leq z \\
1 & \text{如果 } k > z
\end{cases}
$$

重新排列公式，以避免求和无穷尾部的分布：

$$
1 - \sum_{k=0}^{z} \frac{\lambda^k e^{-\lambda}}{k!} \left(1 - \left(\frac{q}{p}\right)^{z-k}\right)
$$

转换为C语言代码：

```c
#include <math.h>
double AttackerSuccessProbability(double q, int z) {
    double p = 1.0 - q;
    double lambda = z * (q / p);
    double sum = 1.0;
    int i, k;
    for (k = 0; k <= z; k++) {
        double poisson = exp(-lambda);
        for (i = 1; i <= k; i++) poisson *= lambda / i;
        sum -= poisson * (1 - pow(q / p, z - k));
    }
    return sum;
}
```

运行一些结果，我们可以看到概率随着 $z$ 的增加呈指数级下降：

| $q$ | $z$ | 概率 $P$ |
|-----|-----|----------|
| 0.1 | 0   | 1.0000000 |
| 0.1 | 1   | 0.2045873 |
| 0.1 | 2   | 0.0509779 |
| 0.1 | 3   | 0.0131722 |
| 0.1 | 4   | 0.0034552 |
| 0.1 | 5   | 0.0009137 |
| 0.1 | 6   | 0.0002428 |
| 0.1 | 7   | 0.0000647 |
| 0.1 | 8   | 0.0000173 |
| 0.1 | 9   | 0.0000046 |
| 0.1 | 10  | 0.0000012 |

| $q$ | $z$ | 概率 $P$ |
|-----|-----|----------|
| 0.3 | 0   | 1.0000000 |
| 0.3 | 5   | 0.1773523 |
| 0.3 | 10  | 0.0416605 |
| 0.3 | 15  | 0.0101008 |
| 0.3 | 20  | 0.0024804 |
| 0.3 | 25  | 0.0006132 |
| 0.3 | 30  | 0.0001522 |
| 0.3 | 35  | 0.0000379 |
| 0.3 | 40  | 0.0000095 |
| 0.3 | 45  | 0.0000024 |
| 0.3 | 50  | 0.0000006 |

求解 $P$ 小于 0.1% 的情况：

| $q$ | $z$ |
|-----|-----|
| 0.10| 5   |
| 0.15| 8   |
| 0.20| 11  |
| 0.25| 15  |
| 0.30| 24  |
| 0.35| 41  |
| 0.40| 89  |
| 0.45| 340 |


## 12. 结论

我们提出了一个**不依赖信任的电子交易系统**。我们从通常的框架开始，即由数字签名构成的货币，它提供了对所有权的强有力控制，但如果没有防止双重支付的方法，这个框架是不完整的。为了解决这个问题，我们提出了一个使用**工作量证明（Proof-of-Work）**的点对点网络，记录交易的公共历史记录。如果诚实节点控制了大多数CPU算力，那么攻击者改变历史记录将变得在计算上极为不切实际。网络以其无结构的简洁性表现出强大的健壮性。节点同时工作，几乎不需要协调。它们不需要被识别，因为消息不是路由到特定位置，只需要尽力而为地传递。节点可以随意离开和重新加入网络，并接受工作量证明链作为它们离开期间发生事件的证明。它们通过CPU算力进行投票，通过扩展有效区块来表达对区块的接受，并通过拒绝在无效区块上工作来拒绝它们。任何必要的规则和激励都可以通过这种共识机制来执行。



这篇论文的核心思想是通过去中心化的网络和密码学技术，实现一种无需信任第三方的电子支付系统，同时解决了双重支付问题。比特币网络的运行机制、激励机制和安全性都基于这种设计。
